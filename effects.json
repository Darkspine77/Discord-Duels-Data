[
  {
    "name": "Resting Assualt",var firebase = require('firebase');
var Discord = require('discord.js');
var express = require('express')
var request = require('request');
var app = express()
var client = new Discord.Client();
var data = {}
var credentials = {
	tokens:{
		live:"MjkyNzg5NTg4Mzk5NzUxMTY4.C8h9ww.MVJsofGLfKBwPL9L2PK5NNVjbCw",
		test:"MjYyNDU1MDQ2ODYyNjY3Nzc2.C0DzFA.Zilj0g89_JdrKLSC-n1n6swtx2E"
	},
	database:{
    apiKey: "AIzaSyBvIB8xSUWBWPBA5OundPByoHWCT4tEDp4",
    authDomain: "discord-duels-8a301.firebaseapp.com",
    databaseURL: "https://discord-duels-8a301.firebaseio.com",
    storageBucket: "discord-duels-8a301.appspot.com"
	}	
}

var version = "0.8.5"
var changelog = ""
changelog += "**" + version + "** \n" 
changelog += "```"
changelog += "-> Attempted a fix for stuns \n"
changelog += "-> Edited Base damage for all weapons \n"
changelog += "-> Removed Machine Learning AI \n"
changelog += "-> Fixed mobs dropping over leveled weapons \n"
changelog += "-> Edited Combos Base Values \n"
changelog += "-> Unwavering spirit now reduces damage dealt\n"
changelog += "-> Changed prices for lives and healing \n"
changelog += "-> Balanced weapons with dizzy and stagger effects to compensate changes \n"
changelog += "-> New weapon in shop: Refurbished Blade Cannon \n"
changelog += "-> New Boss: Paramegonas: The Unholy Abomination\n"
// changelog += "-> Added new weapon to shop (Thx for 500 players :D) \n"
// changelog += "-> Changed how dizzy and stagger effects work \n"
// changelog += "-> Fixed over leveled weapons from shop \n"
// changelog += "-> Fixed healing bug \n"
// changelog += "-> You can now view members in your party\n"
// changelog += "-> Removed wild encounters\n"
// changelog += "-> Usernames will now change according to your discord username\n"
changelog += "```"

request("https://raw.githubusercontent.com/Darkspine77/Discord-Duels-Data/master/bosses.json", function (error, response, body) {
	  if (!error) {
    	data.bosses = JSON.parse(response.body).bosses
    	console.log("Loaded bosses")
    }
})
request("https://raw.githubusercontent.com/Darkspine77/Discord-Duels-Data/master/effects.json", function (error, response, body) {
	  if (!error) {
    	data.effects = JSON.parse(response.body)
    	console.log("Loaded effects")
    }
})
request("https://raw.githubusercontent.com/Darkspine77/Discord-Duels-Data/master/weapons.json", function (error, response, body) {
	  if (!error) {
    	data.weapons = JSON.parse(response.body).weapons
    	console.log("Loaded weapons")
    }
})
request("https://raw.githubusercontent.com/Darkspine77/Discord-Duels-Data/master/creatures.json", function (error, response, body) {
	  if (!error) {
    	data.creatures = JSON.parse(response.body)
    	console.log("Loaded creatures")
    }
})

client.login(credentials.tokens.live);

firebase.initializeApp(credentials.database);

var duels = []
var parties = []
var co_op_mobs = []
var trades = []
var activeBossFighters = []

function completeQuest(player){
	var message = "```"
	message += "Quest complete! \n"
	player.exp += parseInt(player.capExp * 0.10)
		while(player.exp >= player.capExp){
			if(player.level < 30){
				player.level += 1
				player.exp -= player.capExp
				player.max_health = parseInt(player.max_health * 1.085)
				player.health += parseInt(player.max_health * .1)
				if (player.health >= player.max_health) {
					player.health = player.max_health
				}
				player.capExp = parseInt(player.capExp * 1.75)
				message += player.name + " is now level " + player.level + "! \n"
				message += player.name + " gained 1 skillpoint! \n"
				if(player.level >= 30){
					player.level = 30
					player.exp = 0
					player.capExp = 0
				}
				player.skillpoints.availiable += 1;
			} else {
				player.exp = 0
				player.capExp = 0
			}
		}
	player.quest_id = Math.floor(Math.random() * 5)
	player.quest_counter = 0
	if(player.quest_id == 0){
		player.quest_goal = player.level * 10
	}
	if(player.quest_id == 1){
		player.quest_goal = player.level * 75
	}
	if(player.quest_id == 2){
		player.quest_goal = Math.ceil(player.level * 1.5)
	}
	if(player.quest_id == 3){
		player.quest_goal = Math.ceil(player.level/5)
	}
	if(player.quest_id == 4){
		player.quest_goal = player.level * 50
	}
	message += "```"
	client.fetchUser(player.id).then(user => 
		user.createDM().then(dm => {
				dm.sendMessage(message)
			}
		)
	)
	return player
}

function givePlayer(player,item){
	player.inventory.push(item)
	updatePlayer(player,function(){})
}

function generateMob(player,callback){
	createMobPool(player,function(enemies){
		var enemyR = enemies.random()
		var level = player.level + Math.floor(Math.random() * 2) - 1;
		if(level <= 0){
			level = 1
		}
		var weapon_level = level - 1
		var availiablePoints = level
		var skillpoints = {
			strength:0,
			speed:0,
			perception:0
		} 
		for (stat in skillpoints){
			if(availiablePoints > 0){
				var amount = parseInt(Math.random() * availiablePoints)
				skillpoints[stat] = amount
				availiablePoints -= amount
			}
		}
		enemyR.weapon.level = weapon_level
		var enemy = {
			name:enemyR.name,
			combos:[],
			level:level,
			health:parseInt(enemyR.base_health * (enemyR.level_multiplier * level)),
			max_health:parseInt(enemyR.base_health * (enemyR.level_multiplier * level)),
			gold_yield:enemyR.gold_yield,
			expReward:enemyR.exp_level,
			skillpoints:skillpoints, 
			weapon:enemyR.weapon,
			tier:enemyR.tier,
			bonus_health:0,
			drops:enemyR.drops,
			keystones:{
				reckless_fighter:-1,
				giant_slayer:-1,
				strategic_solider:-1,
				hearty_warrior:-1,
				unwavering_spirit:-1,
				focused_mind:-1,
				desperate_mercenary:-1,
				wise_duelist:-1,
				enraged_gladiator:-1,
				points_availible:0,
				assigned:0
			}
		}
		var weaponDrop;
		for (var i = data.weapons.length - 1; i >= 0; i--) {
			if(data.weapons[i].name == enemyR.weapon.name){
				weaponDrop = data.weapons[i]
			}
		};
		var drop = {
			name:enemyR.weapon.name,
			level:enemyR.weapon.level - 4,
			goldToUpgrade:weaponDrop.goldToUpgrade,
			count:1,
			chance:20/enemyR.tier
		}
		if (drop.level <= 0) {
			drop.level = 1
		}
		enemy.drops.push(drop)
		var dropObj = weightedRandom(enemyR.drops)
		if(dropObj.type == "Ranged" || dropObj.type == "Melee"){
			enemy.drop = {
				name:dropObj.name,
				level:dropObj.level - 4,
				goldToUpgrade:dropObj.goldToUpgrade,
				count:dropObj.count
			}
			if(enemy.drop.level < 1){
				enemy.drop.level = 1
			}if(enemy.drop.level > player.level){
				enemy.drop.level = player.level - 1;
			}
		} else {
			enemy.drop = dropObj
		}
		callback(enemy)
	})
}

function getParty(id,callback){
	for (var i = parties.length - 1; i >= 0; i--) {
		if(parties[i].id == id){
			callback(parties[i])
		}
	};
}

function deleteParty(party){
	for (var i = parties.length - 1; i >= 0; i--) {
		if(parties[i].id == party.id){
			parties.splice(i,1)
		}
	};
}

function updateParty(dungeon){
	for (var i = parties.length - 1; i >= 0; i--) {
		if(parties[i].id == dungeon.id){
			parties[i] = dungeon
		}
	};
}

function getCo_OpMob(id){
	for (var i = co_op_mobs.length - 1; i >= 0; i--) {
		if(co_op_mobs[i].id = id){
			return co_op_mobs[i]
		}
	};
}

function updateCo_OpMob(id,mob){
	for (var i = co_op_mobs.length - 1; i >= 0; i--) {
		if(co_op_mobs[i].id = id){
			co_op_mobs[i] = mob
		}
	};	
}

function getHelpText(){
	var finalMessage = ""
	finalMessage += "__Discord Duels by @Darkspine77__ \n \n"
	finalMessage += "** *!refer ** - Refer the game to a friend\n"
	finalMessage += "** *!reddit ** - Link to reddit for Discord Duels \n"
	finalMessage += "** *!prefix ** - Change the prefix for commands \n"
	finalMessage += "** *!info ** - Find out more about game mechanics \n"
	finalMessage += "** *!report** - Report a bug or glitch \n"
	finalMessage += "** *!question** - Ask a question directly to staff\n"
	finalMessage += "** *!create** - Create a player profile \n"
	finalMessage += "** *!remove** - Delete a player profile \n"
	finalMessage += "** *!profile** - View a player profile \n"
	finalMessage += "** *!enemy** - View your current duel opponent \n"
	finalMessage += "** *!duel** - Start one of many different types of duels \n"
	finalMessage += "** *!duels** - See what duels are currently happening \n"
	finalMessage += "** *!spectate** - Spectate a player during their duel \n"
	finalMessage += "** *!endspectate** - Stop spectating a player \n"
	finalMessage += "** *!speak ** - Speak to players in duels\n"
	finalMessage += "** *!suggest ** - Suggest an idea for the game\n"
	finalMessage += "** *!shop ** - View the shop to buy powerful items \n"
	finalMessage += "** *!inventory ** - View your inventory \n"
	finalMessage += "** *!equip ** - Equip a weapon from you inventory\n"
	finalMessage += "** *!keystone** - Manage your keystones\n"
	finalMessage += "** *!party** - Manage your party\n"
	finalMessage += "** *!buylife ** - Buy an extra life \n"
	finalMessage += "** *!version ** - See game version\n"
	finalMessage += "** *!players ** - See number of registered players\n"
	finalMessage += "** *!servers ** - See number of registered servers\n"
	finalMessage += "** *!server ** - Join the Official Discord Duels Server\n"
	finalMessage += "** *!use ** - Use an item from your inventory\n"
	finalMessage += "** *!silence ** - Toggle bot announcements \n"
	finalMessage += "** *!sell ** - Sell and item from your inventory\n"
	finalMessage += "** *!combos ** - Manage combos\n"
	finalMessage += "** *!buy ** - Buy an item from the shop\n"
	finalMessage += "** *!upgrade ** - Upgrade your equipped weapon \n"
	finalMessage += "** *!creature ** - Get info on a creature\n"
	finalMessage += "** *!weapon ** - View weapon stats\n"
	finalMessage += "** *!effect ** - View effect stats\n"
	finalMessage += "** *!skillreset ** - Reset skillpoints \n"
	finalMessage += "** *!skillassign ** - Assign skillpoints\n"
	finalMessage += "** *!leaderboards ** - View leaderboards\n"
	finalMessage += "** *!trade ** - Trade with other players\n"
	finalMessage += "** *!custom** - Manage custom weapon\n"
	finalMessage += "** *!quests** - Manage quests \n"
	finalMessage += "** *!heal ** - Regenerate some health\n"
	finalMessage += "** *!addbot ** - Get install link for Discord Duels\n"
	return finalMessage
}

function makeBoss(){
	var players_data = firebase.database().ref("players");
	players_data.once('value').then(function(snapshot) {
			for(id in snapshot.val()){
				snapshot.val()[id].bossDamage = 0
				snapshot.val()[id].bossRuns = 0
				snapshot.val()[id].bossHits = 0
				updatePlayer(snapshot.val()[id],function(){})
			}
	});
	var boss_data = firebase.database().ref("boss");
	boss_data.once('value').then(function(snapshot) {
		if(snapshot.val() == undefined || snapshot.val() == null){
			var enemyR = data.bosses.random()
			var boss = {
				name:enemyR.name,
				combos:[],
				level:20,
				health:enemyR.base_health,
				max_health:enemyR.base_health,
				skillpoints:enemyR.skillpoints, 
				weapon:enemyR.weapon
			}
			boss_data.update(boss);
		} else {
			boss_data.update(snapshot.val());
		}
	})
}

function deleteDuel(id){
	for (var i = duels.length - 1; i >= 0; i--) {
		if(duels[i].id == id){
			var duel = duels[i]
			for (var x = duel.spectators.length - 1; x >= 0; x--) {
				getPlayer(duel.spectators[x].id,function(player){
					player.spectating = null
					updatePlayer(player,function(){}) 
				})
			};
			duels.splice(i,1);
		} 
	}
}

function getDuel(id,callback){
	for (var i = duels.length - 1; i >= 0; i--) {
		if(duels[i].id == id){
			callback(duels[i])
		} 
	}
}
function deleteTrade(id){
	for (var i = trades.length - 1; i >= 0; i--) {
		if(trades[i].id == id){
			trades.splice(i,1);
		} 
	}
}

function printProfile(player){
	var finalMessage = ""
	finalMessage += "__**"+ player.name.capitalize() + "**__\n"
	finalMessage += "```"
	finalMessage += "Health: " + parseInt(player.health + player.bonus_health) + "/" + parseInt(player.max_health + player.bonus_health) + " \n"
	finalMessage += "Level: " + player.level + " \n"
	finalMessage += "Lives: " + player.lives + " \n"
	finalMessage += "Available Skillpoints: " + player.skillpoints.availiable + " \n"
	finalMessage += "Speed: " + player.skillpoints.speed + " \n"
	finalMessage += "Strength: " + player.skillpoints.strength + " \n"
	finalMessage += "Perception: " + player.skillpoints.perception + " \n"
	finalMessage += "Keystone Points: " + player.keystones.points_availible + " \n"
	finalMessage += "Monsters Slain: " + player.monsters_slain + " \n"
	finalMessage += "Monster Cores: " + player.monster_cores + " \n"
	finalMessage += "Chaos Fragements: " + player.chaos_fragments + " \n"
	finalMessage += "Honor: " + player.honor + " \n"
	finalMessage += "Gold: " + player.gold + " \n"
	finalMessage += "Exp: " + player.exp + "/" + player.capExp + " \n"
	if(player.custom_equipped){
		finalMessage += "Weapon: " + player.custom_weapon.name + " - Lvl " + player.custom_weapon.level + " \n"
	} else {
		finalMessage += "Weapon: " + player.weapon.name + " - Lvl " + player.weapon.level + " \n"
	}
	finalMessage += "Server of Birth: " + player.origin_server + " \n"
	finalMessage += "Date of Birth: " + player.start_time + " \n"
	finalMessage += "```"
	return finalMessage
}

function printDuelist(player){
	var finalMessage = ""
	finalMessage += "__**"+ player.player.name.capitalize() + "**__\n"
	finalMessage += "```"
	finalMessage += "Health: " + parseInt(player.player.health + player.player.bonus_health) + "/" + parseInt(player.player.max_health + player.player.bonus_health) + " \n"
	finalMessage += "Level: " + player.player.level + " \n"
	finalMessage += "Speed: " + player.player.skillpoints.speed + " \n"
	finalMessage += "Strength: " + player.player.skillpoints.strength + " \n"
	finalMessage += "Perception: " + player.player.skillpoints.perception + " \n"
	if(player.player.keystones.points_availible < 12) {
		finalMessage += "Keystones: \n"
		for (name in player.keystones){
			if(player.keystones[name] > -1 && name != "assigned" && name != "points_availible"){
				finalMessage += "	" + name.capitalize().replace(/_/g," ") + ": " + player.keystones[name] + "\n"
			}
		}
	};
	finalMessage += "Weapon: " + player.weapon.name.capitalize() + "\n"
	if(player.weapon.effects){
		finalMessage += "	Effects: "
		for (var i = player.weapon.effects.length - 1; i >= 0; i--) {
			if(player.weapon.effects[i].name != undefined){
				player.weapon.effects[i] = player.weapon.effects[i].name
			}
			finalMessage += player.weapon.effects[i]
			if(i != 0){
			finalMessage += " / "
			}
		}
	}
	finalMessage += "\n"
	finalMessage += "		Rush: " + findScaledValue(player.weapon.moveDamage[0],player.weapon.level) + " \n"
	finalMessage += "		Strike: " + findScaledValue(player.weapon.moveDamage[1],player.weapon.level) + " \n"
	finalMessage += "		Counter: " + findScaledValue(player.weapon.moveDamage[2],player.weapon.level) + " \n"
	finalMessage += "```"
	return finalMessage
}

function printMob(level,creature){
	var finalMessage = ""
	finalMessage += "__**"+ creature.name.capitalize() + "**__\n"
	finalMessage += "```"
	if(level == 0){
		finalMessage += "Health: " + parseInt(creature.base_health * (creature.level_multiplier * 1)) + "-" + parseInt(creature.base_health * (creature.level_multiplier * 30)) + " \n"
	} else {
	finalMessage += "Health: " + creature.base_health * (creature.level_multiplier * level) + " \n"
	}
	finalMessage += "Base Gold Yield: " + creature.gold_yield + " \n"
	finalMessage += "Base Exp Yield: " + creature.exp_level + " \n"
	finalMessage += "Drops:  \n"
	for (var i = creature.drops.length - 1; i >= 0; i--) {
		finalMessage += creature.drops[i].name + " \n"
	};
	finalMessage += "Weapon: " + creature.weapon.name + " \n"
	finalMessage += "```"
	return finalMessage
}

function findScaledValue(minMax,level,multi){
	if(multi == undefined){
		multi = 1
	}
	var value = Math.floor((minMax[0] + (((minMax[1] - minMax[0])/30) * level) * multi)) ;
	return value
}

function printWeapon(level,weapon){
	var finalMessage = ""
	if(weapon.custom){
		finalMessage += "__**"+ weapon.name.capitalize() + " - Level: " + level + "**__\n"
	} else {
		finalMessage += "__**"+ weapon.name.capitalize() + " - #" + weapon.id + " - Level: " + level + "**__\n"
	}
	finalMessage += "```"
	finalMessage += "Type: " + weapon.type + " \n"
	if(level < 20 && level != 0 && weapon.goldToUpgrade != undefined){
		finalMessage += "Upgrade Cost: " + weapon.goldToUpgrade * level + "\n"
	}	
	if(weapon.effects){
		finalMessage += "Effects: "
		for (var i = weapon.effects.length - 1; i >= 0; i--) {
			if(weapon.effects[i].name != undefined){
				weapon.effects[i] = weapon.effects[i].name
			}
			finalMessage += weapon.effects[i] 
			if(i != 0){
			finalMessage += " / "
			}
		}
	}
	if(weapon.souls != undefined){
		finalMessage += "Souls Reaped: " + weapon.souls + " \n"
	}
	finalMessage += "\nDamage \n"
	if(level == 0){
		finalMessage += "(Min - Max) \n"
		finalMessage += "Rush: " + findScaledValue(weapon.moveDamage["0"],1) + " - " + findScaledValue(weapon.moveDamage["0"],30) + " \n" 
		finalMessage += "Strike: " + findScaledValue(weapon.moveDamage["1"],1) + " - " + findScaledValue(weapon.moveDamage["1"],30) + " \n" 
		finalMessage += "Counter: " + findScaledValue(weapon.moveDamage["2"],1) + " - " + findScaledValue(weapon.moveDamage["2"],30) + " \n"  
	} else {
		finalMessage += "Rush: " + findScaledValue(weapon.moveDamage["0"],level) + " \n" 
		finalMessage += "Strike: " + findScaledValue(weapon.moveDamage["1"],level) + " \n" 
		finalMessage += "Counter: " + findScaledValue(weapon.moveDamage["2"],level) + " \n"  	
	}
	finalMessage += "```"
	return finalMessage
}

function printEffect(level,effect){
	var finalMessage = ""
	finalMessage += "__**"+ effect.name.capitalize() + " - #" + effect.id + " - Level: " + level + "**__\n"
	finalMessage += "```"
	if(level == 0){
		finalMessage += effect.effectDescription
		.replace(/RECOIL/g,findScaledValue(effect.recoil,1) + " - " + findScaledValue(effect.recoil,30))
		.replace(/MODIFIER/g,findScaledValue(effect.modifier,1) + " - " + findScaledValue(effect.modifier,30))
		.replace(/STRENGTH/g,findScaledValue(effect.statusStrength,1,100) + " - " + findScaledValue(effect.statusStrength,30,100))
	} else {
		finalMessage += effect.effectDescription
		.replace(/RECOIL/g,findScaledValue(effect.recoil,level))
		.replace(/MODIFIER/g,findScaledValue(effect.modifier,level))
		.replace(/STRENGTH/g,findScaledValue(effect.statusStrength,level,100))
	}
	finalMessage += "```"
	return finalMessage
}

function printCombo(combo){
	var finalMessage = ""
	finalMessage += "__**"+ combo.name.capitalize() + "**__\n"
	finalMessage += "```"
	finalMessage += "Recipe: " + combo.recipe_string + " \n"
	finalMessage += "Level: " + combo.level + " \n"
	finalMessage += "Type: " + combo.stat_modify + " \n"
	finalMessage += "```"
	return finalMessage
}

function printInventory(inventory){
	var messageArray = []
	var message = "```"
	if(inventory != undefined){
		for (var i = inventory.length - 1; i >= 0; i--) {
			message += "Slot #" + parseInt(i+1) + ": " + inventory[i].name  
			if(inventory[i].level != undefined){
				message += " Lvl " + inventory[i].level	
			}
			message += " x" + inventory[i].count + " \n" 
			if(message.length > 1900){
				message += "```"	
				messageArray.push(message)
				message = "```"
			} 
		}
		message += "```"
		messageArray.push(message)	
		return messageArray
	} else {
		message += "No items found in this players inventory \n"
		message += "```"	
		messageArray.push(message)
		return messageArray
	}
}

function printShop() {
	var inventory = []
	for (var i = data.weapons.length - 1; i >= 0; i--) {
		if(data.weapons[i].cost != undefined){
			inventory.push(data.weapons[i])
		}
	}
	var message = "```"
	if(inventory != undefined){
		for (var i = inventory.length - 1; i >= 0; i--) {
			message += "Slot #" + parseInt(i+1) + ": " + inventory[i].name + " | Cost: " + inventory[i].cost + "\n"  
		}
		message += "```"
		return message
	} else {
		message += "No weapons found in this shop page \n"
		message += "```"
		return message
	}	
}

var choiceTemplate = [
	{
		chance:33.33,
		id:"0",
		name:"rushed"		
	},{
		chance:33.33,
		id:"1",
		name:"struck"	
	},{
		chance:33.33,
		id:"2",
		name:"countered"
	}
]

String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
}

Array.prototype.random = function() {
    return this[Math.floor(Math.random() * (this.length))]
}

function weightedRandom(options){
	var chances = [];
	for (var i = options.length - 1; i >= 0; i--) {
		var percent = parseInt(options[i].chance);
		if(i != options.length - 1){
			percent += chances[chances.length - 1];
		}
		chances.push(percent)
	};
	var roll = Math.random() * chances[chances.length -1]
	for (var x = chances.length - 1; x >= 0; x--) {
		if(x == 0){
			if(roll < chances[x]){
				return options.reverse()[x]
			}
		} else {
			if(roll <= chances[x] && roll > chances[x - 1]){
				return options.reverse()[x]
			}
		}
	};
}

function equalizeChance(choices){
	var sum = 0;
	for (var i = choices.length - 1; i >= 0; i--) {
		sum += choices[i].chance
	}
	var modifier = (100 - sum)/choices.length;
	for (var i = choices.length - 1; i >= 0; i--) {
		choices[i].chance += modifier
	}
	return choices
}

function findDuel(message,callback){
	var duel;
	for (var i = duels.length - 1; i >= 0; i--) {
		if(duels[i].type == "bot"){
			if(!message.fake){	
				if(message.author.id == duels[i].player1.player.id){
					duel = duels[i]
				}
			} else {
				if(message.id == duels[i].player1.player.id){
					duel = duels[i]
				}
			}
		}
		if(duels[i].type == "player"){
			if(!message.fake){
				if(message.author.id == duels[i].player1.player.id || message.author.id == duels[i].player2.player.id){
					duel = duels[i]
				}
			} else {
				if(message.id == duels[i].player1.player.id){
					duel = duels[i]
				}
				if(message.spectating){
					if(message.id == duels[i].player1.player.id || message.id == duels[i].player2.player.id){
						duel = duels[i]
					}
				}
			}
		}
	}
	callback(duel)
}

function bossEncounter(message,player){
	var boss_data = firebase.database().ref("boss");
	boss_data.once('value').then(function(snapshot){
		var enemy = snapshot.val()
		if(enemy != null){
			enemy.health += parseInt(player.max_health/2)
			if(enemy.health > enemy.max_health){
				enemy.health = enemy.max_health
			}
			enemy.keystones = {
				reckless_fighter:-1,
				giant_slayer:-1,
				strategic_solider:-1,
				hearty_warrior:-1,
				unwavering_spirit:-1,
				focused_mind:-1,
				desperate_mercenary:-1,
				wise_duelist:-1,
				enraged_gladiator:-1,
				points_availible:0,
				assigned:0
			}
			enemy.custom_weapon = null
			enemy.custom_equipped = false
			enemy.weapon.level = player.weapon.level + 3
			if(enemy.weapon.level > 30){
				enemy.weapon.level = 30
			}
			var newDuel = new Duel(message,player,enemy,"casual",0,0,"bot",true,null)
			enemy.weapon.level = null
			duels.push(newDuel)
			var fightMessage = "```"
	    	fightMessage += player.name.capitalize() + " is now fighting " + newDuel.player2.player.name + "! \n"
	    	fightMessage += "```"
			message.channel.sendMessage(fightMessage)
			if(enemy.members == undefined){
				enemy.members = []
			}
			if(enemy.members.indexOf(player.id) == -1){
			enemy.members.push(player.id)
			}
			activeBossFighters.push(player.id)
			var bossMessage = "```"
	    	bossMessage += player.name.capitalize() + " has hit the boss " + player.bossHits + " times! \n"
	    	bossMessage += "```"
			client.fetchUser(player.id).then(user => 
						user.createDM().then(dm => {
									dm.sendMessage(bossMessage)
								}
							)
						)
			var finalMessage = "```"
	    	finalMessage += player.name.capitalize() + " Lvl " + player.level + " joined the boss fight! \n"
	    	finalMessage += "```"
			for (var i = activeBossFighters.length - 1; i >= 0; i--) {
				client.fetchUser(String(activeBossFighters[i])).then(user => 
						user.createDM().then(dm => {
									dm.sendMessage(finalMessage)
								}
							)
						)
				}
			boss_data.update(enemy);
			var time = new Date
			player.bossRuns += 1
			updatePlayer(player,function(){})
		} else {
			var finalMessage = "```"
	    	finalMessage += "There is currently no boss to fight! \n"
	    	finalMessage += "```"
	    	message.channel.sendMessage(finalMessage)
		}
	})
}

function createMobPool(player,callback){
	var mobPool = []
	for (var i = data.creatures.length - 1; i >= 0; i--) {
		if(data.creatures[i].tier <= Math.ceil(player.level/5)){
			mobPool.push(data.creatures[i])
		}
		if(i == 0){
			callback(mobPool)
		}
	}
}

function wildEncounter(message,player){
	updatePlayer(player,function(){
		findDuel(message,function(duel){
			findTrade(message,function(trade){
				if (trade == undefined && duel == undefined && player.spectating == null) {
					generateMob(player,function(enemy){
						var newDuel = new Duel(message,player,enemy,"casual",enemy.expReward,enemy.gold_yield,"bot",false,null)
						duels.push(newDuel)
						var finalMessage = "```"
				    	finalMessage += player.name.capitalize() + " was attacked by " + newDuel.player2.player.name + " Lvl " + newDuel.player2.player.level +  "! \n"
				    	finalMessage += "```"
						message.channel.sendMessage(finalMessage)	
					})		
				}
			})
		})		
	})
}

function findTrade(message,callback){
	var trade;
	for (var i = trades.length - 1; i >= 0; i--) {
		if(!message.fake){
			if(message.author.id == trades[i].player1.player.id || message.author.id == trades[i].player2.player.id){
				trade = trades[i]
			}
		} else {
			if(message.id == trades[i].player1.player.id){
				trade = trades[i]
			}
		}
	}
	callback(trade)
}

function getPlayer(id,callback){
	var player_data = firebase.database().ref("players/" + String(id));
	var player;
	player_data.once('value').then(function(snapshot) {
			player = snapshot.val()
			callback(player)
	});
}

function updatePlayer(player,callback){
	var player_data = firebase.database().ref("players/" + String(player.id));
	player_data.update(player);
	callback(player)
}

function updateDuel(duel,callback){
	for (var i = duels.length - 1; i >= 0; i--) {
		if(duels[i].id == duel.id){
			duels[i] = duel
			callback(duels[i])
		}
	};
}

function removePlayer(player,callback){
	var player_data = firebase.database().ref("players/");
	player_data.once('value').then(function(snapshot) {
		snapshot.forEach(function(child) {
			if(child.val().id == player.id){
		        child.ref.remove();
		        callback(player)
	    	}
	    });
	});
}

function playerDBRefresh(playerid,callback){
	getPlayer(playerid,function(player){
			var player_data = firebase.database().ref("players/" + String(player.id));
			var inventory = []
			if(player.inventory != undefined){
				inventory = player.inventory
			} else {
				player.inventory = inventory
			}
			for (var i = player.inventory.length - 1; i >= 0; i--) {
				if(player.inventory[i].level > player.level){
					player.inventory[i].level = player.level
				}
			};
			if(player.weapon.level > player.level){
				player.weapon.level = player.level
			}
			var combos = []
			if(player.combos == undefined){
				player.combos = combos
			}
			if (isNaN(player.health)) {
				player.health = player.max_health * 0.5
			}
			if (player.health < 0) {
				player.health = player.max_health * 0.5
			}
			if(player.lives == undefined){
			player.lives = 0
			}
			if(player.bossDamage == undefined){
				player.bossDamage = 0
			}
			var hasReffered = []
			if(player.hasReffered != undefined){
				hasReffered = player.hasReffered
			}
			var custom_weapon;
			if(player.custom_weapon){
				if(player.custom_weapon.level > player.level){
					player.custom_weapon.level = player.level
				}
				custom_weapon = player.custom_weapon
			} else {
				custom_weapon = null
			}
			var custom_equipped = false;
			if(player.custom_equipped){
				custom_equipped = player.custom_equipped
			}
			var honor;
			if(player.honor){
				honor = player.honor
			} else {
				honor = 0
			}
			var chaos_fragments = false;
			if(player.chaos_fragments){
				chaos_fragments = player.chaos_fragments
			} else {
				chaos_fragments = 0
			}
			if(player.lives > 20){
				player.lives = 20
			}
			var percentOfExp = player.exp/player.capExp
			var capExp = Math.ceil(50 * Math.pow(1.45,player.level - 1))
			var exp = Math.ceil(percentOfExp * capExp)
			var percentOfHealth = player.health/player.max_health
			var capHealth = Math.ceil(100 * Math.pow(1.085,player.level - 1))
			var health = Math.ceil(percentOfHealth * capHealth)
			var newPlayer = {
				name:player.name,
				id:player.id,
				strength:[],
				mention:player.mention,
				last_seen:player.last_seen,
				searching_for_duel:false,
				searching_type:"casual",
				casual_wins:player.casual_wins,
				origin_server:player.origin_server,
				start_time:player.start_time,
				combos:player.combos,
				inventory:inventory,
				monsters_slain:player.monsters_slain,
				health:health,
				max_health:capHealth,
				weapon:player.weapon,
				capExp:capExp,
				exp:exp,
				gold:parseInt(player.gold),
				level:player.level,
				recieveAlerts:player.recieveAlerts,
				spectating:null,
				skillpoints:player.skillpoints,
				lives:player.lives,
				bossDamage:player.bossDamage,
				bossDelay:0,
				bossHits:player.bossHits,
				bossRuns:player.bossRuns,
				prefix:player.prefix,
				monster_cores:player.monster_cores,
				honor:honor,
				wild_runs:0,
				wild_timer:0,
				custom_weapon:custom_weapon,
				custom_equipped:custom_equipped,
				chaos_fragments:chaos_fragments,
				hasReffered:hasReffered,
				quest_counter:player.quest_counter,
				quest_id:player.quest_id,
				quest_goal:player.quest_goal,
				keystones:player.keystones,
				dungeon:null,
				lives_purchased:0,
				life_timer:0
			}
			player_data.update(newPlayer);
			callback()
	})
}

function createPlayer(message,callback){
	var player_data = firebase.database().ref("players/" + String(message.author.id));
	var weaponinfo = data.weapons[0]	
	var weapon = {
		name:weaponinfo.name,
		level:weaponinfo.level,
		cost:weaponinfo.cost,
		count: 1,
		goldToUpgrade:weaponinfo.goldToUpgrade
	}
	var name;
	if(message.member != null){
		if (message.member.nickname == null) {
			name = message.author.username
		} else {
			name = message.member.nickname
		}
		var player = {
			name:name,
			id:message.author.id,
			mention:message.author.toString(),
			last_seen:message.guild.name,
			searching_for_duel:false,
			searching_type:"casual",
			casual_wins:0,
			origin_server:message.guild.name,
			start_time:new Date().toLocaleDateString(),
			combos:[],
			inventory:[],
			monsters_slain:0,
			bonus_health:0,
			health:100,
			max_health:100,
			weapon:weapon,
			capExp:50,
			exp:0,
			gold:0,
			level:1,
			recieveAlerts:true,
			spectating:null,
			skillpoints:{
				strength:0,
				speed:0,
				perception:0,
				availiable:1
			},
			lives:2,
			custom_equipped:false,
			bossDamage:0,
			bossDelay:0,
			bossHits:0,
			bossRuns:0,
			prefix:"*!",
			monster_cores:0,
			honor:0,
			wild_runs:0,
			wild_timer:0,
			chaos_fragments:0,
			quest_counter:0,
			quest_id:0,
			quest_goal:10,
			keystones:{
				reckless_fighter:-1,
				giant_slayer:-1,
				strategic_solider:-1,
				hearty_warrior:-1,
				unwavering_spirit:-1,
				focused_mind:-1,
				desperate_mercenary:-1,
				wise_duelist:-1,
				enraged_gladiator:-1,
				points_availible:12,
				assigned:0
			},
			lives_purchased:0,
			life_timer:0
		}
		player.weapon.level = 1
		player_data.update(player);
		callback(player)
	} else {
		var finalMessage = "```"
		finalMessage += "You must use the *!create command in a server \n"
		finalMessage += "```"
		message.channel.sendMessage(finalMessage)
	}
}

class Trade{
	constructor(message,player1,player2){
		var id = "";
		for (var i = 9; i >= 0; i--) {
			id += parseInt(Math.random() * 9)
		}
		this.id = parseInt(id)
		this.player1 = {}
		this.player2 = {}
		this.player1.player = player1
		this.player2.player = player2
		this.players = [this.player1,this.player2]
		for (var i = this.players.length - 1; i >= 0; i--) {
			this.players[i].offer;
			this.players[i].selectedItemIndex;
			this.players[i].confirm;
			if (this.players[i].player.inventory == undefined) {
				this.players[i].player.inventory = []
			}
			
		}
		this.started = false
		var finalMessage = "```"
		finalMessage += "You have invited " + player2.name + " to a trade! \n"
		finalMessage += "Type *!tdecline to decline \n"
		finalMessage += "```"
		this.wumbo(this.player1.player,finalMessage)
		finalMessage = "```"
		finalMessage += "You have been invited to a trade by " + player1.name + "! \n"
		finalMessage += "Type *!taccept to accept \n" 
		finalMessage += "Type *!tdecline to decline \n"
		finalMessage += "```"
		this.wumbo(this.player2.player,finalMessage)
	}
		wumbo(player,message){
			var saved_message
			client.fetchUser(String(player.id)).then(user => 
				user.createDM().then(dm => {
							dm.sendMessage(message).then(message => {
								// message.delete(15000)
							})
						}
					)
				)
		}

		confirm(player){
			if(player.id == this.player1.player.id){
				this.dmPlayers(this.player1.player.name + " accepts the trade")
				this.player1.confirm = true
			}
			if(player.id == this.player2.player.id){
				this.dmPlayers(this.player2.player.name + " accepts the trade")
				this.player2.confirm = true
			}
			if(this.player1.confirm && this.player2.confirm){
				this.processTrade()
			}
		}

		update(player,item,amount,index){
			if(player.id == this.player1.player.id){
				this.dmPlayers(this.player1.player.name + " has offered " + amount + " " + item.name)
				this.player1.offer = item
				this.player1.selectedItemIndex = index
				for (var i = this.players.length - 1; i >= 0; i--) {
					this.players[i].confirm = false
				}
			}
			if(player.id == this.player2.player.id){
				this.dmPlayers(this.player2.player.name + " has offered " + amount + " " + item.name)
				this.player2.offer = item
				this.player2.selectedItemIndex = index
				for (var i = this.players.length - 1; i >= 0; i--) {
					this.players[i].confirm = false
				}
			}
		}

		dmPlayers(message){
				this.wumbo(this.player1.player,message)
				this.wumbo(this.player2.player,message)
		}

		start(){
			var finalMessage = ""
			finalMessage += "```"
			finalMessage += "The trade between " + this.player1.player.name + " and " + this.player2.player.name + " has started! \n" 
			finalMessage += "```"
			finalMessage += "** How to trade ** \n"
			finalMessage += "```"
			finalMessage += "Usage: *!offer (inventory index) (amount) \n"
			finalMessage += "Example_1: *!offer 1 1 \n"
			finalMessage += "Type *!confirm to confirm trade offers \n" 
			finalMessage += "```"
			this.dmPlayers(finalMessage)
			this.started = true;
		}

		end(player){
			var finalMessage = "```"
			finalMessage += player.name + " declined the trade request. \n"
			finalMessage += "```"
			this.dmPlayers(finalMessage)
			deleteTrade(this.id)
		}

		processTrade(){
			if(this.player2.offer != undefined && this.player2.selectedItemIndex != undefined){
				var itemsName = []
				for (var i = this.player1.player.inventory.length - 1; i >= 0; i--) {
					itemsName.push(this.player1.player.inventory[i].name)
				}
				if(itemsName.reverse().indexOf(this.player2.offer.name) != -1){
					this.player1.player.inventory[itemsName.reverse().indexOf(this.player2.offer.name)].count += this.player2.offer.count
				} else {
					this.player1.player.inventory.push(this.player2.offer)
				}
				if (this.player2.offer.count == this.player2.player.inventory[this.player2.selectedItemIndex - 1].count) {
				this.player2.player.inventory.splice(this.player2.selectedItemIndex - 1,1)
				} else {
					this.player2.player.inventory[this.player2.selectedItemIndex - 1].count -= this.player2.offer.count
				}
			}
			if(this.player1.offer != undefined && this.player1.selectedItemIndex != undefined){
				var itemsName = []
				for (var i = this.player2.player.inventory.length - 1; i >= 0; i--) {
					itemsName.push(this.player2.player.inventory[i].name)
				}
				if(itemsName.reverse().indexOf(this.player1.offer.name) != -1){
					this.player2.player.inventory[itemsName.reverse().indexOf(this.player1.offer.name)].count += this.player1.offer.count
				} else {
					this.player2.player.inventory.push(this.player1.offer)
				}
				if (this.player1.offer.count == this.player1.player.inventory[this.player1.selectedItemIndex - 1].count) {
				this.player1.player.inventory.splice(this.player1.selectedItemIndex - 1,1)
				} else {
					this.player1.player.inventory[this.player1.selectedItemIndex - 1].count -= this.player1.offer.count
				}
			}
			var p1 = this.player1
			var p2 = this.player2	
			var trade = this
			updatePlayer(p1.player,function(){
				updatePlayer(p2.player,function(){
					trade.dmPlayers("Trade successful")
					deleteTrade(trade.id)
				})
			})
		}
	}
class Duel {
	constructor(message,player1,player2,rating,expReward,gold_reward,type,boss,co_op_id){
		var id = "";
		for (var i = 9; i >= 0; i--) {
			id += parseInt(Math.random() * 9)
		}
		this.boss = boss
		this.co_op = false
		this.co_op_id = co_op_id
		if(this.co_op_id != null){
			player2 = getCo_OpMob(this.co_op_id)
			this.co_op = true
		}
		this.id = parseInt(id)
		this.suddenDeathCount = 1
		this.spectators = []
		this.player1 = {};
		this.player2 = {};
		this.player1.player = player1;
		this.player2.player = player2;
		this.player1.preHealth = player1.health;
		this.player2.preHealth = player2.health;
		this.players = [this.player1,this.player2]
		for (var i = this.players.length - 1; i >= 0; i--) {
			if(this.players[i].player.custom_equipped){
				this.players[i].weapon = this.players[i].player.custom_weapon
			} else {
				for (var y = data.weapons.length - 1; y >= 0; y--) {
					if(data.weapons[y].name == this.players[i].player.weapon.name){
						this.players[i].weapon = data.weapons[y]	
						this.players[i].weapon.level = this.players[i].player.weapon.level
					}
				}
			}
			this.players[i].target = undefined
			this.players[i].finaldmg = 0
			this.players[i].history = ['3']
			this.players[i].combo_input = []
			this.players[i].ready = false;
			this.players[i].choice;
			this.players[i].statuses = [];
			this.players[i].moveCount = {
			0:0,
			1:0,
			2:0
			}
			if(type == "player"){
				this.players[i].player.health = this.players[i].player.max_health
			}
			this.players[i].additionalDamage = 0;
		}
		this.channel = message.channel
		this.started = false
		this.round = 1;
		this.type = type
		this.expReward = expReward
		this.gold_reward = gold_reward
		this.rating = rating
		if(this.type == "player"){ 
			this.channel = message.channel
			if(this.rating == "casual"){
				var finalMessage = "```" 
				finalMessage += "You have challenged " + player2.name + " to a duel! \n"
				finalMessage += "Type *!decline to decline \n"
				finalMessage += "```"
				this.wumbo(this.player1.player,finalMessage)
				finalMessage = "```"
				finalMessage += "You have been challenged to a duel by " + player1.name + "! \n"
				finalMessage += "Type *!accept to accept \n" 
				finalMessage += "Type *!decline to decline \n"
				finalMessage += "```"
				this.wumbo(this.player2.player,finalMessage)
			}
		} else {
		this.guild = message.guild
		var finalMessage = "** How to attack ** \n"
		finalMessage += "```"
		finalMessage += "Usage: *!(attack) \n"
		finalMessage += "Example: *!rush \n"
		finalMessage += "Attacks: rush / counter / strike \n"
		finalMessage += "Use *!escape to flee \n"
		finalMessage += "```"
		this.wumbo(this.player1.player,finalMessage)
		}
	}

	choose(callback){
		this.player2.ready = true;
		var choice = choiceTemplate[Math.floor(Math.random() * 3)]
		callback(choice)
	}

	start(){
		var finalMessage = ""
		finalMessage += "```"
		finalMessage += this.player1.player.name + " vs " + this.player2.player.name + " begins now! \n" 
		finalMessage += "```"
		finalMessage += "** How to attack ** \n"
		finalMessage += "```"
		finalMessage += "Usage: *!(attack) \n"
		finalMessage += "Example: *!rush \n"	
		finalMessage += "Attacks: rush / counter / strike \n \n"
		finalMessage += "Type *!forfeit to forfeit \n" 
		finalMessage += "```"
		this.dmPlayers(finalMessage)
		this.started = true;
	}

	end(player){
		var finalMessage = "```"
		finalMessage += player.name + " declined the challenge. \n"
		finalMessage += "```"
		this.dmPlayers(finalMessage)
		deleteDuel(this.id)
	}

	escape(){
		var fleeDmg =  parseInt(this.player1.player.max_health)  * (parseInt((Math.random() * 6) - 3) + 12)/100	
		if(fleeDmg < 0){
			fleeDmg = 1
		} 
		this.player1.player.health -= fleeDmg
		if(this.player1.player.health <= 0){
			this.player1.player.health = 1
		}
		var finalMessage = "```"
		finalMessage += this.player1.player.name + " ran from battle and lost " + parseInt(fleeDmg) + " health!"
		finalMessage += "```"
		this.dmPlayers(finalMessage)
		this.channel.sendMessage(finalMessage)
		if(this.boss){
			var boss_data = firebase.database().ref("boss");
			var duel = this
			boss_data.once('value').then(function(snapshot) {
				var boss = snapshot.val()
				activeBossFighters.splice(activeBossFighters.indexOf(duel.player1.player.id),1)
				boss_data.update(boss);
			})
		}
		var duel = this
		updatePlayer(this.player1.player,function(){
			deleteDuel(duel.id)
		})
	}

	forfeit(player){
			var winner;
			var loser;
			var finalMessage = "```"
			finalMessage += "The duel has been forfeited by " + player.name + ". \n"
			finalMessage += "```"
			this.dmPlayers("The duel has been forfeited by " + player.name + ".")
			if(player.id == this.player1.player.id){
				winner = this.player2.player
				loser = this.player1.player
			}
			if(player.id == this.player2.player.id){
				winner = this.player1.player
				loser = this.player2.player
			}
			winner.casual_wins += 1
			var channelMessage = "```"
			channelMessage += loser.name + " has forfeited to " + winner.name + "! \n"
			channelMessage += "```"
			this.channel.sendMessage(channelMessage)
			var id = this.id
			updatePlayer(winner,function(){
				updatePlayer(loser,function(){
					deleteDuel(id)
				})
			})
	}

	wumbo(player,message){
		var saved_message;
		client.fetchUser(String(player.id)).then(user => 
			user.createDM().then(dm => {
						dm.sendMessage(message).then(message => {
						})
					}
				)
			)
	}

	dmPlayers(message){
		if(this.type == "player"){
			this.wumbo(this.player1.player,message)
			this.wumbo(this.player2.player,message)
		} else {
			if(this.co_op){
				getParty(this.player2.player.id,function(dungeon){
					for (var i = dungeon.players.length - 1; i >= 0; i--) {
						client.fetchUser(dungeon.players[i]).then(user => 
							user.createDM().then(dm => {
										dm.sendMessage(message).then(message => {
										})
									}
								)
							)
					};
				})
			} else if(this.boss){
				var boss_data = firebase.database().ref("boss");
				boss_data.once('value').then(function(snapshot) {
					for (var i = activeBossFighters.length - 1; i >= 0; i--) {
						client.fetchUser(activeBossFighters[i]).then(user => 
						user.createDM().then(dm => {
									dm.sendMessage(message).then(message => {
									})
								}
							)
						)
					};
				})
			} else {
				this.wumbo(this.player1.player,message)
			}
		}
		for (var i = this.spectators.length - 1; i >= 0; i--) {
			this.wumbo(this.spectators[i],message)
		};
	}

	update(player,choice){
		if(this.type == "player"){
			if(player.id == this.player1.player.id && !this.player1.ready){
				this.dmPlayers("**" + this.player1.player.name + " is ready.**")
				this.player1.choice = choice
				this.player1.ready = true;
			}
			if(player.id == this.player2.player.id && !this.player2.ready){
				this.dmPlayers("**" + this.player2.player.name + " is ready.**")
				this.player2.choice = choice
				this.player2.ready = true;
			}
			if(this.player2.ready && this.player1.ready){
				this.getResult()
			}
		} else {
			this.player1.choice = choice
			this.player1.ready = true;
		}
	}

	checkEffect(effect,player,winner,callback){
    	for (var x = data.effects.length - 1; x >= 0; x--) {
    		if(effect == data.effects[x].name){
    			effect = data.effects[x]
    		}
    	}
    	if(effect.effectOnMoves == undefined){
    		console.log(effect)
    	}
		for (var i = effect.effectOnMoves.length - 1; i >= 0; i--) {
			if(effect.effectOnMoves[i] == player.choice.id){
				if(effect.chance == 0 || parseInt(Math.random() * 100) < effect.chance){
					var counters = true
					var success = true
					var returnObj = {
						value:0,
						status:null,
						effectModifier:effect.effectModifier,
						overpower:effect.overpower,
						recoilDamage:findScaledValue(effect.recoil,player.weapon.level),
						target:effect.statusTarget
					}
					if(effect.requiresCounters){
						counters = false
							var flag = {
								0:false,
								1:false,
								2:false
							}
							if(effect.requiredCounters.length != undefined){
								for (var x = effect.requiredCounters.length - 1; x >= 0; x--) {
									if(effect.requiredCounters[x] == -1){
										flag[String(x)] = true
									} else {
										flag[String(x)] = player.moveCount[String(x)] >= effect.requiredCounters[x];
									}
								}
							} else {
								if(player.history.length == effect.requiredCounters - 1){
									flag = {
										0:true,
										1:true,
										2:true
									}
								}
							}
						if (flag[String(0)] && flag[String(1)] && flag[String(2)]){
							counters = true
						}
					}
					if(effect.requiresSuccess != 0){
						var success = false
						var req = effect.requiresSuccess 
						if (req == 1 && winner == player){
							success = true
						}
						if (req == -1 && winner != player && winner != "tie"){
							success = true
						}
						if (req == 2 && winner == "tie"){
							success = true
						}
					}
					if(counters && success){
						if(effect.applyStatus){
							returnObj.status = {
								duration:effect.statusDuration,
								type:effect.statusEffect,
								strength:findScaledValue(effect.statusStrength,player.weapon.level,100)/100
							}
						}
						returnObj.value = findScaledValue(effect.modifier,player.weapon.level)
						if(effect.modiferValueEqualsCounters) {
						returnObj.value = findScaledValue(effect.modifier,player.weapon.level) * player.moveCount[effect.equalCounter]
						}
						if(effect.clearCounters){
							player.moveCount = {
								0:0,
								1:0,
								2:0
							}
						}
						callback(returnObj);
					} else {
						callback(undefined)
					}	
				}		
			}
		}
	}

	getResult(){
		var matchWinner;
		if(this.player2.choice.id == "0" && this.player1.choice.id == "0"){
			matchWinner = "tie"
		}
		if(this.player2.choice.id == "0" && this.player1.choice.id == "1"){
			matchWinner = this.player2
		}
		if(this.player2.choice.id == "0" && this.player1.choice.id == "2"){
			matchWinner = this.player1
		}
		if(this.player2.choice.id == "1" && this.player1.choice.id == "0"){
			matchWinner = this.player1
		}
		if(this.player2.choice.id == "1" && this.player1.choice.id == "1"){
			matchWinner = "tie"
		}
		if(this.player2.choice.id == "1" && this.player1.choice.id == "2"){
			matchWinner = this.player2
		}
		if(this.player2.choice.id == "2" && this.player1.choice.id == "0"){
			matchWinner = this.player2
		}
		if(this.player2.choice.id == "2" && this.player1.choice.id == "1"){
			matchWinner = this.player1
		}
		if(this.player2.choice.id == "2" && this.player1.choice.id == "2"){
			matchWinner = "tie"
		}
		this.player2.history.push(this.player2.choice.id)
		this.player1.history.push(this.player1.choice.id)
		var message = ""
		if(this.type == "bot"){
			if(this.boss){
				message += "__**" + this.player1.player.name+ " vs " + this.player2.player.name + " - " + activeBossFighters.length + " Player(s)-**__ \n"
			} else {
				message += "__**Turn #" + this.round + " - " + this.player1.player.mention + " vs " + this.player2.player.name + "**__ \n"
			}
		} else {
		message += "__**Turn #" + this.round + " - " + this.player1.player.name + " vs " + this.player2.player.name + "**__ \n"
		}
		message += "```"
		for (var i = this.players.length - 1; i >= 0; i--) {
			if(this.players[i].status != undefined){
				var flag = true
				if(this.players[i].player.keystones.focused_mind > 0){
					var chance = 5 * this.players[i].player.keystones.focused_mind
					if(Math.floor(Math.random * 100) < chance){
						flag = false
					}
				}
				this.players[i].status.duration -= 1
				if(flag){
					if(this.players[i].status.type == "stun"){
						this.players[i].dmg = 0
						this.players[i].attackName = "was stunned"
						if(this.players[i].player.id == this.player1.player.id){
							matchWinner = this.player2
						} else {
							matchWinner = this.player1
						}
					}
					if(this.players[i].status.type == "bleed"){
						var DOT = parseInt(this.players[i].player.max_health * this.players[i].status.strength)
						if(this.boss && this.players[i].player.id == this.player2.player.id){
							DOT = DOT/50
						}
						message += this.players[i].player.name + " is hurt from their wound and took " + DOT  + " damage! \n"
						this.players[i].player.health -= DOT;
					}
					if(this.players[i].status.type == "dizzy"){
							var DOT = parseInt(this.players[i].dmg * this.players[i].status.strength)
							message += this.players[i].player.name + " can't focus well and hurt themselves for " + DOT  + " damage! \n"
							this.players[i].player.health -= DOT;
					}
				}
			}
		}
		for (var i = this.players.length - 1; i >= 0; i--) {
			if(this.players[i].status == undefined || this.players[i].status.type != "stun"){
				this.players[i].combo = undefined;
				this.players[i].combo_input.push(parseInt(this.players[i].choice.id))
				if(this.players[i].combo_input.length > 3){
					this.players[i].combo_input.splice(0,1)
				}
				if(this.players[i].combo_input.length > 3){
					this.players[i].combo_input.splice(0,1)
				}
				if(this.players[i].player.combos != undefined){
					for (var x = this.players[i].player.combos.length - 1; x >= 0; x--) {
							var flag = (this.players[i].player.combos[x].recipe[0] == this.players[i].combo_input[0])
							var flag1 = (this.players[i].player.combos[x].recipe[1] == this.players[i].combo_input[1])
							var flag2 = (this.players[i].player.combos[x].recipe[2] == this.players[i].combo_input[2])
					 		if(flag1 && flag2 && flag){
					 			this.players[i].combo = this.players[i].player.combos[x]
					 		}
					}
				}
				this.players[i].comboStat = {
					damage:1,
					heal:0,
					evade:false,
					resist:0
				}
				if(this.players[i].combo != undefined){
					this.players[i].combo_input = []
					message += this.players[i].player.name + " activated combo " + this.players[i].combo.name + "! \n \n"
					if(this.players[i].combo.stat_modify == "damage"){
							this.players[i].comboStat.damage = 1 + (.12 * this.players[i].combo.level)
					}
					if(this.players[i].combo.stat_modify == "heal"){
							this.players[i].comboStat.heal = parseInt(this.players[i].player.max_health * (.025 * this.players[i].combo.level))
					}
					if(this.players[i].combo.stat_modify == "resist"){
							this.players[i].comboStat.resist = .10 * this.players[i].combo.level
					}
					if(this.players[i].combo.stat_modify == "evade"){
						var roll = parseInt(Math.random() * 100)
						if(roll <= this.players[i].combo.amount * this.players[i].combo.level){
							this.players[i].comboStat.evade = true
						}
					}
				}
			}
		}
		for (var i = this.players.length - 1; i >= 0; i--) {
			if(this.players[i].status == undefined || this.players[i].status.type != "stun"){
				var additionalDamage = 0;
				var additionalHealth = 0;
				var recoilDamage = 0
				var overpower = false
				this.players[i].moveCount[this.players[i].choice.id] += 1
				additionalHealth += this.players[i].comboStat.heal
				var player = this.players[i]
				var player1 = this.player1
				var player2 = this.player2
				if(player.weapon.effects){
					for (var x = player.weapon.effects.length - 1; x >= 0; x--) {
						this.checkEffect(player.weapon.effects[x],player,matchWinner,function(returnObj){
							if(returnObj != undefined){
								message += player.player.name + " activated weapon effect " + player.weapon.effects[x] + "! \n \n"
								if (returnObj.recoilDamage > 0){
										recoilDamage += returnObj.recoilDamage
								}
								overpower = returnObj.overpower
								if(returnObj.value != 0){
									if (returnObj.effectModifier == "damage") {
										additionalDamage += returnObj.value
									}
									if (returnObj.effectModifier == "lessdamage") {
										additionalDamage -= returnObj.value
									}
									if (returnObj.effectModifier == "heal") {
										additionalHealth += returnObj.value
									}
								}
								if(returnObj.status != null){
									if(player.player.id == player1.player.id){
										if(returnObj.target == "enemy"){
											if(player2.status == undefined && player2.comboStat.evade == false){
												player2.status = returnObj.status
											}
										} else if(returnObj.target == "self" && player1.status == undefined){
											player1.status = returnObj.status
										}
									} else {
										if(returnObj.target == "enemy"){
											if(player1.status == undefined && player1.comboStat.evade == false){
												player1.status = returnObj.status
											}
										} else if(returnObj.target == "self" && player2.status == undefined){
											player2.status = returnObj.status
										}
									}
								}
							}
						})
					}
				}
				this.players[i].overpower = overpower
				this.players[i].additionalDamage = additionalDamage
				this.players[i].dmg = findScaledValue(this.players[i].weapon.moveDamage[this.players[i].choice.id],this.players[i].weapon.level)
				this.players[i].dmg += this.players[i].additionalDamage
				this.players[i].dmg = parseInt(this.players[i].dmg * this.players[i].comboStat.damage)
				this.players[i].additionalDamage = 0
				if(this.players[i].dmg < 0){
					this.players[i].dmg = 0
				}
				if(this.players[i].player.keystones.strategic_solider > 0){
					if(this.players[i].choice.id != this.players[i].history[this.players[i].history.length - 2]){
						this.players[i].dmg += Math.ceil(this.players[i].dmg  * (1 + (0.05 * this.players[i].player.keystones.strategic_solider)))
					}
				}
				if(this.players[i].player.keystones.giant_slayer > 0){
					if(!this.boss){
						if(this.players[i].player.id == this.player1.player.id){
							this.players[i].dmg += Math.ceil(this.player2.player.max_health * (0.01 * this.players[i].player.keystones.giant_slayer))
						} else {
							this.players[i].dmg += Math.ceil(this.player1.player.max_health * (0.01 * this.players[i].player.keystones.giant_slayer))
						}
					} else {
						if(this.players[i].player.id == this.player1.player.id){
							this.players[i].dmg += Math.ceil(this.player2.player.max_health * (0.00025 * this.players[i].player.keystones.giant_slayer))
						} else {
							this.players[i].dmg += Math.ceil(this.player1.player.max_health * (0.00025 * this.players[i].player.keystones.giant_slayer))
						}
					}
				}
				if(this.players[i].player.keystones.reckless_fighter > 0){
					this.players[i].dmg = Math.ceil(this.players[i].dmg * (1 + (0.2 * this.players[i].player.keystones.reckless_fighter)))
					recoilDamage += Math.ceil(this.players[i].dmg * (0.15 * this.players[i].player.keystones.reckless_fighter))
				}
				if(this.players[i].player.keystones.enraged_gladiator > 0){
					if(this.players[i].health < this.players[i].max_health * 0.4){
						this.players[i].dmg += Math.ceil(this.players[i].dmg  * (1 + (0.40 * this.players[i].player.keystones.enraged_gladiator)))
					}
				}
				if(this.players[i].player.keystones.hearty_warrior > 0){
					additionalHealth += Math.ceil(this.players[i].max_health * (0.03 * this.players[i].player.keystones.hearty_warrior))
				}
				if(this.players[i].player.keystones.desperate_mercenary > 0){
					additionalHealth += Math.ceil(this.players[i].dmg * (0.015 * this.players[i].player.keystones.desperate_mercenary))
				}
				if(recoilDamage > 0){
					message += player.player.name + " took " + recoilDamage + " damage from recoil! \n"
				}
				this.players[i].player.health -= recoilDamage
				this.players[i].player.health += parseInt(additionalHealth)
				if(this.players[i].player.health >= this.players[i].player.max_health){
					this.players[i].player.health = this.players[i].player.max_health
				}
				if(parseInt(additionalHealth) > 0){
					message += player.player.name + " gained " + parseInt(additionalHealth) + " health! \n \n"
				}
			}
		}
		for (var i = this.players.length - 1; i >= 0; i--) {
			if(this.players[i].status != undefined){
				if(this.players[i].status.type == "stagger"){
					message += this.players[i].player.name + " staggered while trying to attack! \n"
					this.players[i].dmg = this.players[i].dmg * 0.75
				}
				if(this.players[i].status.duration == 0){
					this.players[i].status = undefined;
				}
			}
		}
		if(matchWinner == this.player2){
			if(this.type == "bot"){
			}
			this.player2.finaldmg = (this.player2.dmg)
			this.player1.finaldmg = (parseInt(this.player1.dmg * .25)) 
		}
		if(matchWinner == this.player1){
			if(this.player1.player.quest_id == 2){
				this.player1.player.quest_counter += parseInt(additionalHealth)
				if(this.player1.player.quest_counter >= this.player1.player.quest_goal){
					this.player1.player = completeQuest(this.player1.player)
				}
			}
			if(this.type == "bot"){
			}
			this.player2.finaldmg = (parseInt(this.player2.dmg * .25))
			this.player1.finaldmg = (this.player1.dmg) 
		}
		if(matchWinner == "tie"){
			this.player1.finaldmg = (parseInt(this.player1.dmg * .5))
			this.player2.finaldmg = (parseInt(this.player2.dmg * .5))
		}
		if(this.player1.player.keystones.wise_duelist > 0){
			if(winner != this.player1){
				this.player1.finaldmg = (parseInt(this.player1.dmg * (0.50 + 0.05 * this.player1.player.keystones.wise_duelist))) 
			}
		}
		if(this.player2.player.keystones.wise_duelist > 0){
			if(winner != this.player2){
				this.player2.finaldmg = (parseInt(this.player2.dmg * (0.50 + 0.05 * this.player2.player.keystones.wise_duelist))) 
			}
		}
		if(this.player1.overpower){
			this.player1.finaldmg = this.player1.dmg
			this.player1.attackName = "is overpowering"
		}
		if(this.player2.overpower){
			this.player2.finaldmg = this.player2.dmg
			this.player2.attackName = "is overpowering"
		}
		if(this.player1.player.keystones.unwavering_spirit > 0){
				this.player2.finaldmg = this.player2.finaldmg * (1 - (0.08 * this.player1.player.keystones.unwavering_spirit))
				this.player1.finaldmg = this.player1.finaldmg * (1 - (0.03 * this.player1.player.keystones.unwavering_spirit))
		}
		if(this.player2.player.keystones.unwavering_spirit > 0){
				this.player1.finaldmg = this.player1.finaldmg * (1 - (0.08 * this.player2.player.keystones.unwavering_spirit))
				this.player2.finaldmg = this.player2.finaldmg * (1 - (0.03 * this.player2.player.keystones.unwavering_spirit))
		}
		this.player1.target = this.player2
		this.player2.target = this.player1
		for (var i = this.players.length - 1; i >= 0; i--) {
			if(this.players[i].choice.id == "0"){
				this.players[i].finaldmg = this.players[i].finaldmg * (1 + ((this.players[i].player.skillpoints.speed/30) - (this.players[i].target.player.skillpoints.perception/40) + (this.players[i].target.player.skillpoints.strength/20)))
			}
			if(this.players[i].choice.id == "1"){
				this.players[i].finaldmg = this.players[i].finaldmg * ( 1 + ((this.players[i].player.skillpoints.strength/30) - (this.players[i].target.player.skillpoints.speed/40) + (this.players[i].target.player.skillpoints.perception/20)))
			}
			if(this.players[i].choice.id == "2"){
				this.players[i].finaldmg = this.players[i].finaldmg * ( 1 + ((this.players[i].player.skillpoints.perception/30) - (this.players[i].target.player.skillpoints.strength/40) + (this.players[i].target.player.skillpoints.speed/20)))
			}
			this.players[i].finaldmg = parseInt(this.players[i].finaldmg)
		}
		if(this.player1.status == undefined || this.player1.status.type != "stun"){
			if(this.player1.comboStat.evade){
				this.player2.finaldmg = 0
				this.player1.attackName = "evaded"
			}
		}
		if(this.player2.status == undefined || this.player2.status.type != "stun"){
			if(this.player2.comboStat.evade){
				this.player1.finaldmg = 0
				this.player2.attackName = "evaded"
			}
		}
		if(this.player2.status == undefined || this.player2.status.type != "stun"){
			this.player1.finaldmg = parseInt(this.player1.finaldmg * (1 - this.player2.comboStat.resist))
		}
		if(this.player1.status == undefined || this.player1.status.type != "stun"){
			this.player2.finaldmg = parseInt(this.player2.finaldmg * (1 - this.player1.comboStat.resist))
		}
		if(this.player2.attackName == undefined){
			message += this.player2.player.name + " " + this.player2.choice.name + " and dealt " + this.player2.finaldmg + " damage! \n"
		} else {
			message += this.player2.player.name + " " + this.player2.attackName + " and dealt " + this.player2.finaldmg + " damage! \n"
		}
		message += " \n"
		if(this.player1.attackName == undefined){
			message += this.player1.player.name + " " + this.player1.choice.name + " and dealt " + this.player1.finaldmg + " damage! \n"
		} else {
			message += this.player1.player.name + " " + this.player1.attackName + " and dealt " + this.player1.finaldmg + " damage! \n"
		}
		for (var i = this.players.length - 1; i >= 0; i--) {
			this.players[i].attackName = undefined
			if(this.players[i].player.quest_id == 1){
				this.players[i].player.quest_counter += this.players[i].finaldmg
				if(this.players[i].player.quest_counter >= this.players[i].player.quest_goal){
					this.players[i].player = completeQuest(this.players[i].player)
				}
			}
			if(this.players[i].player.id == this.player1.player.id){
				if(this.players[i].player.quest_id == 4){
					this.players[i].player.quest_counter += this.player2.finaldmg
					if(this.players[i].player.quest_counter >= this.players[i].player.quest_goal){
						this.players[i].player = completeQuest(this.players[i].player)
					}
				}
			}
			if(this.players[i].player.id == this.player2.player.id){
				if(this.players[i].player.quest_id == 4){
					this.players[i].player.quest_counter += this.player1.finaldmg
					if(this.players[i].player.quest_counter >= this.players[i].player.quest_goal){
						this.players[i].player = completeQuest(this.players[i].player)
					}
				}
			}
		};
		this.player1.player.health -= this.player2.finaldmg
		this.player2.player.health -= this.player1.finaldmg
		if(this.boss){
			this.player1.player.bossDamage += this.player1.finaldmg 
			var boss_data = firebase.database().ref("boss");
			boss_data.update(this.player2.player)
		}
		if(this.co_op){
			updateCo_OpMob(this.co_op_id,this.player2.player)
		}
		if(this.player1.player.health > 0 && this.player2.player.health > 0){
		this.player2.player.health = parseInt(this.player2.player.health)	
		this.player1.player.health = parseInt(this.player1.player.health)
		message += " \n"
		message += this.player1.player.name + " has " + this.player1.player.health + " health remaining \n "
		message += " \n"
		message += this.player2.player.name + " has " + this.player2.player.health + " health remaining \n"
		message += "```"
		this.dmPlayers(message)
		this.round += 1;
		this.player1.ready = false
		this.player2.ready = false
		} else {
			if (this.player1.player.health <= 0 && this.player2.player.health <= 0 ){
				this.player1.player.health = (parseInt(this.player1.player.max_health * (.1 * this.suddenDeathCount) + 1))
				this.player2.player.health = (parseInt(this.player2.player.max_health * (.1 * this.suddenDeathCount) + 1))
				message += "**SUDDEN DEATH** \n"
				message += this.player1.player.name + "'s health has been set to " + (parseInt(this.player1.player.max_health * (.1 * this.suddenDeathCount) + 1)) + " \n"
				message += this.player2.player.name + "'s health has been set to " + (parseInt(this.player2.player.max_health * (.1 * this.suddenDeathCount) + 1)) + " \n"
				message += "``` \n"
				this.round += 1;
				this.player1.ready = false
				this.player2.ready = false
				if(this.suddenDeathCount < 10){
					this.suddenDeathCount += 1
				}
				this.dmPlayers(message)
				if(this.boss){
					var boss_data = firebase.database().ref("boss");
					boss_data.update(this.player2.player)
				}
				if(this.co_op){
					updateCo_OpMob(this.co_op_id,this.player2)
				}
			} else {
				var winner;
				var loser;
				if (this.player1.player.health <= 0){
					message += this.player2.player.name + " has " + this.player2.player.health + " health remaining \n"
					message += this.player2.player.name + " has defeated " + this.player1.player.name + "! \n"
					var channelMessage = "```"
					channelMessage += this.player2.player.name + " has defeated " + this.player1.player.name + "! \n"
					channelMessage += "```"
					this.channel.sendMessage(channelMessage)
					winner = this.player2.player
					loser = this.player1.player
					if (this.type == "player" || this.player2.player.bot) {
						winner.health = this.player2.preHealth
						loser.health = this.player1.preHealth
					}
				}
				if(this.player2.player.health <= 0){
					message += this.player1.player.name + " has " + this.player1.player.health + " health remaining \n"
					message += this.player1.player.name + " has defeated " + this.player2.player.name + "! \n"
					var channelMessage = "```"
					channelMessage += this.player1.player.name + " has defeated " + this.player2.player.name
					if(this.type == "bot"){
						channelMessage += " Lvl " + this.player2.player.level + "! \n"
					} else {	
						channelMessage += "! \n"
					}
					channelMessage += "```"
					this.channel.sendMessage(channelMessage)
					winner = this.player1.player
					loser = this.player2.player
					if (this.type == "player" || this.player2.player.bot) {
						loser.health = this.player2.preHealth
						winner.health = this.player1.preHealth
					}
				}
				if(isNaN(winner.health)){
					winner.health = Math.ceil(winner.max_health * .1)
				}
				if(isNaN(loser.health)){
					loser.health = Math.ceil(loser.max_health * .1)
				}
				if(!this.boss && !this.co_op){
					var expGained = parseInt((1 + (this.expReward * .1)) * (loser.level * 15) * Math.pow((loser.level/winner.level),1.1))
					var goldGained = parseInt(this.gold_reward * (loser.level * 1.2))
					if(expGained > 0){
						message += winner.name + " gained " + expGained + " experience! \n"
						if(winner.level < 30){
							winner.exp += expGained
						}
						while(winner.exp >= winner.capExp){
							if(winner.level < 30){
								winner.level += 1
								winner.exp -= winner.capExp
								winner.max_health = parseInt(winner.max_health * 1.085)
								winner.health += parseInt(winner.max_health * .1)
								if (winner.health >= winner.max_health) {
									winner.health = winner.max_health
								}
								winner.capExp = parseInt(winner.capExp * 1.75)
								message += winner.name + " is now level " + winner.level + "! \n"
								message += winner.name + " gained 1 skillpoint! \n"
								if(winner.level == 30){
									winner.level = 30
									winner.exp = 0
									winner.capExp = 1
								}
								winner.skillpoints.availiable += 1;
							} else {
								winner.exp = 0
								winner.capExp = 0
							}
						}
					}
					if(goldGained > 0){
						message += winner.name + " gained " + goldGained + " gold! \n"
						winner.gold += goldGained
					}
					if(winner.gold < 0 ){
		    			winner.gold = 0
		    		}
	    		}
				if(this.type == "player"){
					winner.honor += loser.level
					if(winner.quest_id == 3){
						winner.quest_counter += 1
						if(winner.quest_counter >= winner.quest_goal){
							winner = completeQuest(winner)
						}
					}
					message += "``` \n"
					this.dmPlayers(message)
					var id = this.id
					winner.casual_wins += 1
					updatePlayer(winner,function(){
						updatePlayer(loser,function(){
							deleteDuel(id)
						})
					})
				} else {
					if(winner.custom_equipped){
						winner.custom_weapon.souls += 1
					}
					if(winner.id == this.player1.player.id){
						winner.monsters_slain += 1
						if(winner.quest_id == 0){
							winner.quest_counter += 1
							if(winner.quest_counter >= winner.quest_goal){
								winner = completeQuest(winner)
							}
						}
						if(!this.boss && !this.co_op){
							if(loser.tier != undefined){
								winner.monster_cores += parseInt(loser.tier * loser.level)
							}
							message += "\n" + winner.name + " received " + loser.tier * loser.level + " monster cores!"
							if (loser.drop != undefined && loser.drop.name != "nothing"){
								message += "\n" + winner.name + " received " + loser.drop.count + " " + loser.drop.name + "!"
								var added = false
								if (winner.inventory == undefined) {
									winner.inventory = []
								}
								for (var i = winner.inventory.length - 1; i >= 0; i--) {
									if(winner.inventory[i].name == loser.drop.name){
										winner.inventory[i].count += 1
										added = true
									}
								}
								if(!added){
									winner.inventory.push(loser.drop)
								}
							}
						} else if(this.boss){
							var boss_data = firebase.database().ref("boss");
							boss_data.once('value').then(function(snapshot){
								activeBossFighters = []
								for (var i = snapshot.val().members.length - 1; i >= 0; i--) {
									getPlayer(snapshot.val().members[i],function(player){
										if(player.bossHits >= 10){
											player.lives += 1
											if(player.lives > 20){
												player.lives = 20
											}
											player.chaos_fragments += 1
											player.gold += player.bossDamage * 3
											player.bossDamage = 0
											player.monster_cores += 2000
											for (var i = duels.length - 1; i >= 0; i--) 	{
												if(duels[i].boss){
													duels.splice(i,1)
												}
											};
											updatePlayer(player,function(){})
										}
									})
								};
								snapshot.forEach(function(child){
								        child.ref.remove();
							    });
							    makeBoss()
							})
							message += "Players who hit the boss 10+ times have been rewarded with gold, 1 extra life, 1000 monster cores, and a chaos fragment! \n"
						} else if(this.co_op){
							var duel = this
							getParty(duel.co_op_id,function(party){
								var level = party.level/party.players.length
								var expGained = parseInt((1 + (duel.expReward * .1)) * (loser.level * 15) * Math.pow((loser.level/level),1.3))
								var goldGained = parseInt(duel.gold_reward * (loser.level * 1.2))
								message += "Party members recieved " + goldGained + " gold! \n"
								message += "Party members recieved " + expGained + " experience! \n"
								if (loser.drop != undefined && loser.drop.name != "nothing"){
									message += "Party members received " + loser.drop.count + " " + loser.drop.name + "!"
								}
								for (var i = party.players.length - 1; i >= 0; i--) {
									getPlayer(party.players[i],function(partyMember){
										if(loser.tier != undefined){	
											partyMember.monster_cores += parseInt(loser.tier * loser.level)
										}
										if (loser.drop != undefined && loser.drop.name != "nothing"){
											var added = false
											if (partyMember.inventory == undefined) {
												partyMember.inventory = []
											}
											for (var i = partyMember.inventory.length - 1; i >= 0; i--) {
												if(partyMember.inventory[i].name == loser.drop.name){
													partyMember.inventory[i].count += 1
													added = true
												}
											}
											if(!added){
												partyMember.inventory.push(loser.drop)
											}
										}
										partyMember.gold += goldGained
										partyMember.exp += expGained
										while(partyMember.exp >= partyMember.capExp){
											if(partyMember.level < 30){
												partyMember.level += 1
												partyMember.exp -= partyMember.capExp
												partyMember.max_health = parseInt(partyMember.max_health * 1.085)
												partyMember.health += parseInt(partyMember.max_health * .1)
												if (partyMember.health >= partyMember.max_health) {
													partyMember.health = partyMember.max_health
												}
												partyMember.capExp = Math.ceil(partyMember.capExp * 1.45)
												message += partyMember.name + " is now level " + partyMember.level + "! \n"
												message += partyMember.name + " gained 1 skillpoint! \n"
												if(partyMember.level >= 30){
													partyMember.level = 30
													partyMember.exp = 0
													partyMember.capExp = 0
												}
												partyMember.skillpoints.availiable += 1;
											} else {
												partyMember.exp = 0
												partyMember.capExp = 0
											}
										}
										updatePlayer(partyMember,function(){})
									})
								};
								for (var i = duels.length - 1; i >= 0; i--) {
									if(duels[i].player2.player.id == duel.player2.player.id){
										deleteDuel(duels[i].id)
										co_op_mobs.splice(co_op_mobs.indexOf(getCo_OpMob(duel.player2.player.id)),1)
									}
								};
							})
						}
						message += "``` \n"
						this.dmPlayers(message)
						var id = this.id
						updatePlayer(winner,function(){
							deleteDuel(id)
						})
					} else {
						if(this.boss){
							var boss_data = firebase.database().ref("boss");
							var duel = this
							boss_data.once('value').then(function(snapshot){
								var boss = snapshot.val()
								activeBossFighters.splice(activeBossFighters.indexOf(duel.player1.player.id),1)
								boss_data.update(boss)
							})
						}
						if(this.player1.player.lives == 0){
			    			message += "\nThe Legend of " + this.player1.player.name.capitalize() + " has come to an end... \n"
			    			message += "```"
			    			console.log(this.player1.player.name.capitalize() + " has died!")
							this.dmPlayers(message)
							deleteDuel(this.id)
		    				removePlayer(this.player1.player,function(player){
							})					
		    			} else {
			    			message += "\n" + this.player1.player.name.capitalize() + " has lost a life! \n"
			    			message += "```"
			    			this.player1.player.health = this.player1.player.max_health
			    			this.dmPlayers(message)
		    				var id = this.id
		    				loser.lives -= 1
		    				updatePlayer(loser,function(){
								deleteDuel(id)
							})
		    			}
					}
				}
			}
		}
	}
}

// client.on('guildMemberAdd', member => {
// 	getPlayer(member.id,function(player){
// 		if(player == undefined){
// 			var finalMessage = "```"
// 			finalMessage += "This server has the Discord Duels game installed \n"
// 			finalMessage += "To join the fun please type *!create \n"
// 			finalMessage += "For commands type *!help \n"
// 			finalMessage += "For game info type *!info \n"
// 			finalMessage += "```"
// 		} else {
// 			var finalMessage = "```"
// 			finalMessage += player.name + ", you joined a server where Discord Duels is installed!"
// 			finalMessage += "```"
// 			player.last_seen == member.guild.name
// 		}
// 		client.fetchUser(member.id).then(user => 
// 			user.createDM().then(dm => {
// 					dm.sendMessage(finalMessage)
// 				}
// 			)
// 		)
// 	})
// })

client.on('ready', () => {
	console.log("Starting Duels v" + version + " ...")
	var servers = client.guilds.array()
	console.log("Connected to "+ (servers.length - 1) + " servers")
	var playerNum = 0;
	var player_data = firebase.database().ref("players/");
	player_data.once('value').then(function(snapshot) {
		var players = snapshot.val()
		for(player in players){
			playerNum += 1;
		}
		console.log("Updating " + playerNum + " player profiles...")
		var updateCount = 0
		for(player in players){
			playerDBRefresh(player,function(){
				updateCount += 1
				if(updateCount == playerNum){
					console.log("Finished updating player profiles")
					client.user.setGame("Discord Duels v" + version)
					// setInterval(function(){
					// 	console.log("Pinged"); 
					// }, 5000);

				}
			})
		}
	})
	var boss_data = firebase.database().ref("boss");
	boss_data.once('value').then(function(snapshot) {
		if(snapshot.val() != null){
			var boss = snapshot.val()
			activeBossFighters = []
			boss.skillpoints = {
				strength:0,
				speed:0,
				perception:0
			}
			boss_data.update(boss);
		}
	})
});

client.on('guildCreate', guild => {
	console.log("Joined " + guild.name)
	finalMessage = "```"
	finalMessage += "Thank your for adding Discord Duels to your server! \n"
	finalMessage += "The bot is currently in version " + version + ". \n"
	finalMessage += "If you are blocking direct mesages from this bot, it will not function properly. \n"
	finalMessage += "To avoid spam you may use all of the bots commands in a private message channel with the bot. \n"
	finalMessage += "Type *!help to view all of the commands. \n"
	finalMessage += "Type *!info for game info. \n"
	finalMessage += "To get into the action, type *!create to make an account and *!duel to start fighting! \n"
	finalMessage += "If you have any questions please send a friend request to Darkspine77#1365 so that I can help you get the bot working \n"
	finalMessage += "```"
	guild.defaultChannel.sendMessage(finalMessage)
	client.fetchUser(guild.ownerID).then(user => 
		user.createDM().then(dm => {
				dm.sendMessage(finalMessage)
			}
		)
	)
})

client.on('guildDelete', guild => {
	console.log("Left " + guild.name)
})

client.on('message', message => {
	var rawinput = message.content.trim().split(" ");
    var input = message.content.toLowerCase().trim().split(" ");
    if(message.author != client.user){
	    getPlayer(message.author.id,function(player){
	    	var flag;
	    	if(player != undefined){
	    		flag = player.prefix.toLowerCase() == input[0].substring(0,player.prefix.length) || "*!" == input[0].substring(0,2)
	    	} else {
	    		if (input[0] == "*!create" && input.length >= 1 )  {
		    			createPlayer(message,function(player){
		    				console.log(player.name.capitalize() + " has joined the game!")
		    				console.log(message.author.username + "#" +  message.author.discriminator)
		    				client.fetchUser("163809334852190208").then(user => 
								user.createDM().then(dm => {
										dm.sendMessage(message.author.username + "#" +  message.author.discriminator)
									}
								)
							)
		    				var finalMessage = "```"
		    				finalMessage += "The Legend of " + player.name.capitalize() + " Begins! \n"
		    				finalMessage += "Use *!help to list commands \n"
							if(input[1] != undefined){
								getPlayer(input[1],function(player2){
									var flag = player2.hasReffered
									if (player2 != undefined) {
										if(player2.hasReffered == undefined){
											player2.hasReffered = []
										}
										if(player2.hasReffered.indexOf(player.id) == -1){
											finalMessage += "Inspired by The Legend of " + player2.name.capitalize() + "! \n"
											player2.monster_cores += 75
											player2.gold += 500
											player2.hasReffered.push(player.id)
											client.fetchUser(player2.id).then(user => 
												user.createDM().then(dm => {
														dm.sendMessage(player.name.capitalize() + " created an account based on your referal! Enjoy 500 gold and 75 monster cores!")
													}
												)
											)
											updatePlayer(player2,function(){
												finalMessage += "```"
												message.channel.sendMessage(finalMessage)
											})
										} else {
											finalMessage += "This legend was already inspired by The Legend of " + player2.name.capitalize() + "! \n"
											finalMessage += "```"
											message.channel.sendMessage(finalMessage)
										}
									} else {
										finalMessage += "```"
										message.channel.sendMessage(finalMessage)
									}
								})
							} else {
							finalMessage += "```"
							message.channel.sendMessage(finalMessage)
							}
		    			})
				}
	    		if(input[0] == "*!help" && input.length == 1){
					message.channel.sendMessage("Check your private messages")
					var finalMessage = getHelpText()
					client.fetchUser(String(message.author.id)).then(user => 
						user.createDM().then(dm => {
									dm.sendMessage(finalMessage)
								}
							)
						)
				}
	    		flag = "*!" == input[0].substring(0,2)
	    	}
	    	if(flag){
	    		if(player.name != message.author.username){
	    			player.name = message.author.username
	    			updatePlayer(player,function(){})
	    		}
	    		if("*!" != input[0].substring(0,2)){
		    		input[0] = input[0].replace(player.prefix.toLowerCase(),"*!")
		    	}
		    	if(player != undefined){
				    	if(input[0] == "*!duel") {
				    		if(input.length == 2){
					    		findDuel(message,function(duel){
					    			findTrade(message,function(trade){
						    			if(duel == undefined && trade == undefined && player.spectating == null && player.dungeon == undefined){
						    				if(input[1] == "practice"){
						    					var id = ""
						    					for (var i = 4; i >= 0; i--) {
						    						id += parseInt(Math.random() * 9)
						    					}
												var weaponinfo = data.weapons[0]
												var weapon = {
														name:weaponinfo.name,
														level:1
												}
						    					var bot = {
						    						bot:true,
													name:"Test dummy #" + id,
													combos:[],
													health:100000,
													level:1,
													max_health:100000,
													weapon:weapon,
													skillpoints: {
														strength:0,
														speed:0,
														perception:0
													},
													keystones:{
														reckless_fighter:-1,
														giant_slayer:-1,
														strategic_solider:-1,
														hearty_warrior:-1,
														unwavering_spirit:-1,
														focused_mind:-1,
														desperate_mercenary:-1,
														wise_duelist:-1,
														enraged_gladiator:-1,
														points_availible:0,
														assigned:0
													},
													custom_equipped:false,
													custom_weapon:undefined	 
												}
							    				var newDuel = new Duel(message,player,bot,"casual",0,0,"bot",false,null)
							    				duels.push(newDuel)
							    				var finalMessage = "```"
						    					finalMessage += player.name.capitalize() + " started a duel against " + newDuel.player2.player.name + "! \n"
						    					finalMessage += "```"
							    				message.channel.sendMessage(finalMessage)
						    				} else if(input[1].substring(0,2) == "<@" && input[1].slice(-1) == ">"){
						    					getPlayer(input[1].split("@")[1].replace(">","").replace("!",""),function(player2){
						    						if(player2 != undefined){
							    						var message2 = {
							    							fake: true,
							    							id: player2.id
							    						}
							    						findDuel(message2,function(duel2){
							    							findTrade(message2,function(trade2){
								    							if(duel2 == undefined && trade2 == undefined && player2.spectating == null){
								    								if(player.id != player2.id){
										    						var newDuel = new Duel(message,player,player2,"casual",0,0,"player",false,null)
										    						duels.push(newDuel)
										    						} else {
										    							message.channel.sendMessage("You can't duel yourself!")
										    						}
										    					} else {
										    						message.channel.sendMessage(player2.name.capitalize() + " is already in a duel, trade, or is spectating!")
										    					}
										    				})
							    						})
							    					} else {
							    						message.channel.sendMessage("Could not find non-bot player on this server")
							    					}
						    					})
						    				} else if(input[1] == "global"){
						    					player.searching_for_duel = true
						    					player.searching_type = "casual"
						    					updatePlayer(player,function(){
						    						var player_data = firebase.database().ref("players/");
													player_data.once('value').then(function(snapshot) {
													var players = snapshot.val()
													var finalMessage = "```"
														finalMessage += "Searching for opponent... \n"
														finalMessage += "type *!cancel to leave matchmaking queue \n"
														finalMessage += "```"
														message.channel.sendMessage(finalMessage)
														var playerids = []
														for(id in players){
															playerids.push(id)
														}
														playerids.sort(function(a, b){return 0.5 - Math.random()});
														for (var i = playerids.length - 1; i >= 0; i--) {
															getPlayer(playerids[i],function(player2){
																var message2 = {
									    							fake: true,
									    							id: player2.id
									    						}
									    						findDuel(message2,function(duel2){
									    							if (duel2 == undefined){
																		if (player2.searching_for_duel && player2.searching_type == "casual") {
																			if(player.id != player2.id){
																				player.searching_for_duel = false
																				player2.searching_for_duel = false
																				updatePlayer(player,function(){
																					updatePlayer(player2,function(){
																						var newDuel = new Duel(message,player,player2,"casual",0,0,"player",false,null)
													    								duels.push(newDuel)
																					})
																				})
												    						}
																		}
																	}
																})
															})
														}
													})
						    					})
						    				} else if(input[1] == "wild"){
												player.health += parseInt(player.max_health * .06)
												if (player.health >= player.max_health) {
													player.health = player.max_health
												}
												if(player.wild_runs < 5 * Math.ceil(player.level/8)){
													player.wild_runs += 1
													var now = new Date()
													player.wild_timer = now.getTime() + 180
													wildEncounter(message,player)
												} else {
													var now = new Date()
													if(now.getTime() > player.wild_timer){
														player.wild_runs = 1
														player.wild_timer = now.getTime() + 180
														wildEncounter(message,player)
													} else {
														finalMessage = "```"	
								    					finalMessage += "You have run out of wild runs \n"
														finalMessage += "You must wait " + parseInt((player.wild_timer - now.getTime())/1000) + " seconds before gaining more runs \n"
														finalMessage += "```"
													    message.channel.sendMessage(finalMessage)	
													}
												}
						    				} else if(input[1] == "boss"){
						    					var now = new Date()
						    					if(player.bossRuns < 3){
													player.bossRuns += 1
													var now = new Date()
													player.bossDelay = now.getTime() + 300000
													bossEncounter(message,player)
												} else {
													var now = new Date()
													if(now.getTime() > player.bossDelay){
														player.bossRuns = 1
														player.bossDelay = now.getTime() + 300000
														bossEncounter(message,player)
													} else {
														finalMessage = "```"	
								    					finalMessage += "You have run out of boss runs \n"
														finalMessage += "You must wait " + parseInt((player.bossDelay - now.getTime())/1000) + " seconds before gaining more runs \n"
														finalMessage += "```"
													    message.channel.sendMessage(finalMessage)	
													}
												}
						    				}
						    			} else {
						    				finalMessage = "```"	
										finalMessage += "You cannot complete this action while in a duel, trade, in a party, or while spectating! \n"
										finalMessage += "```"
									    message.channel.sendMessage(finalMessage)		
						    			}
					    			})
					    		})
							} else {
								finalMessage = "** *!duel ** \n"
								finalMessage += "```"
								finalMessage += "Function: Initiates a duel \n"
								finalMessage += "Usage: *!duel (Opponent) \n"
								finalMessage += "Example_1: *!duel practice\n"
								finalMessage += "Example_2: *!duel @Darkspine77\n"
								finalMessage += "Example_3: *!duel wild\n"
								finalMessage += "Example_4: *!duel boss\n"
								finalMessage += "Example_5: *!duel global\n"
								finalMessage += "```"
								message.channel.sendMessage(finalMessage)
							}
					    }
					    if (input[0] == "*!trade") {
					    	if(input.length == 2 ){
					    		findDuel(message,function(duel){
						    		findTrade(message,function(trade){
						    			if(trade == undefined && duel == undefined){
											if(input[1].substring(0,2) == "<@" && input[1].slice(-1) == ">"){
						    					getPlayer(input[1].split("@")[1].replace(">","").replace("!",""),function(player2){
						    						if(player2 != undefined){
							    						var message2 = {
							    							fake: true,
							    							id: player2.id
							    						}
							    						findTrade(message2,function(trade2){
							    							if(trade2 == undefined){
							    								if(player.id != player2.id){
									    						var newTrade = new Trade(message,player,player2)
									    						trades.push(newTrade)
									    						} else {
									    							message.channel.sendMessage("You can't trade yourself!")
									    						}
									    					} else {
									    						message.channel.sendMessage(player2.name.capitalize() + " is already in a trade!")
									    					}
							    						})
							    					} else {
							    						message.channel.sendMessage("Could not find non-bot player on this server")
							    					}
						    					})
						    				}
						    			} else {
						    				finalMessage = "```"
										finalMessage += "You cannot complete this action while in a duel or trade! \n"
										finalMessage += "```"
									    message.channel.sendMessage(finalMessage)		
						    			}
						    		})
								})
					    	} else {
					    		finalMessage = "** *!trade ** \n"
								finalMessage += "```"
								finalMessage += "Function: Invites a player to trade \n"
								finalMessage += "Usage: *!trade (Player) \n"
								finalMessage += "Example: *!trade @Darkspine77 \n"
								finalMessage += "```"	
								message.channel.sendMessage(finalMessage)
					    	}
					    }
					    if (input[0] == "*!rush" || input[0] == "*!r") {
					    	findDuel(message,function(duel){
					    		if(duel != undefined){
					    			var action = {
						    			name:"rushed",
						    			id:"0"
						    		}
						    		duel.update(player,action)
						    		if(duel.type == "bot"){
						    			duel.choose(function(choice){
						    				duel.player2.choice = choice
						    				if(duel.boss){
												duel.player1.player.bossHits += 1
												var boss_data = firebase.database().ref("boss");
												boss_data.once('value').then(function(snapshot){
													duel.player2.player = snapshot.val()
													duel.player2.weapon.level = duel.player1.weapon.level
													updateDuel(duel,function(duel2){
														duel2.getResult()
													})
												})
											} else {
												if(duel.co_op){
													duel.player2.player = getCo_OpMob(duel.co_op_id)
												}
												duel.getResult()
											}
						    			})
						    		}
					    		} else {
					    			message.channel.sendMessage(player.name.capitalize() + " is not currently in a duel!")
					    		}
					    	})
					    }
					    if (input[0] == "*!strike" || input[0] == "*!s") {
					    	findDuel(message,function(duel){
					    		if(duel != undefined){
					    			var action = {
						    			name:"struck",
						    			id:"1"
						    		}
						    		duel.update(player,action)
						    		if(duel.type == "bot"){
						    			duel.choose(function(choice){
						    				duel.player2.choice = choice
						    				if(duel.boss){
												duel.player1.player.bossHits += 1
												var boss_data = firebase.database().ref("boss");
												boss_data.once('value').then(function(snapshot){
													duel.player2.player = snapshot.val()
													updateDuel(duel,function(duel2){
														duel2.getResult()
													})
												})
											} else {
												if(duel.co_op){
													duel.player2.player = getCo_OpMob(duel.co_op_id)
												}
												duel.getResult()
											}	
						    			})
						    		}
					    		} else {
					    			message.channel.sendMessage(player.name.capitalize() + " is not currently in a duel!")
					    		}
					    	})
					    }
					    if (input[0] == "*!counter" || input[0] == "*!c") {
					    	findDuel(message,function(duel){
					    		if(duel != undefined){
						    		var action = {
						    			name:"countered",
						    			id:"2"
						    		}
						    		duel.update(player,action)
						    		if(duel.type == "bot"){
						    			duel.choose(function(choice){
						    				duel.player2.choice = choice
						    				if(duel.boss){
												duel.player1.player.bossHits += 1
												var boss_data = firebase.database().ref("boss");
												boss_data.once('value').then(function(snapshot){
													duel.player2.player = snapshot.val()
													duel.player2.weapon.level = duel.player1.weapon.level
													updateDuel(duel,function(duel2){
														duel2.getResult()
													})
												})
											} else {
												if(duel.co_op){
													duel.player2.player = getCo_OpMob(duel.co_op_id)
												}
												duel.getResult()
											}	
						    			})
						    		}
					    		} else {
					    			message.channel.sendMessage(player.name.capitalize() + " is not currently in a duel!")
					    		}
					    	})
					    }
					    if (input[0] == "*!escape" || input[0] == "*!e") {
					    	findDuel(message,function(duel){
					    		if(duel != undefined){
						    		if(duel.type == "bot"){
						    			duel.escape()	
						    		} else {
						    			message.channel.sendMessage("You can not escape from a player battle!")
						    		}
					    		} else {
					    			message.channel.sendMessage(player.name.capitalize() + " is not currently in a duel!")
					    		}
					    	})
					    }
					    if (input[0] == "*!offer") {
					    	if(input.length == 3){
						    	findTrade(message,function(trade){
						    		if(trade != undefined){
						    			if (player.inventory != undefined) {
						    				if(parseInt(input[2]) > 0){
								    			var item = player.inventory[parseInt(input[1]) - 1]
								    			var amount = parseInt(input[2])
								    			if (item != undefined){
								    				if (amount <= item.count) {
								    					item.count = amount
								    					trade.update(player,item,amount,parseInt(input[1]))
								    				} else {
								    					message.channel.sendMessage(player.name.capitalize() + "does not have " + amount + " " + item.name)
								    				}
									    		} else {
									    			message.channel.sendMessage("No item found at index " + parseInt(input[1]) + " in the inventory of " + player.name.capitalize() + "!")
									    		}
									    	} else {
								    				message.channel.sendMessage("You must trade at least 1 of an item")
								    		}
								    	} else {
								    		message.channel.sendMessage(player.name.capitalize() + "'s inventory is empty!")
								    	}
						    		} else {
						    			message.channel.sendMessage(player.name.capitalize() + " is not currently in a trade!")
						    		}
						    	})
						    } else {
						    	finalMessage = "** *!offer ** \n"
								finalMessage += "```"
								finalMessage += "Function: Offer an item \n"
								finalMessage += "Usage: *!offer (inventory index) (amount) \n"
								finalMessage += "Example: *!offer 1 1 \n"
								finalMessage += "```"	
						    	message.channel.sendMessage(finalMessage)
						    }
					    }
					    if (input[0] == "*!confirm") {
					    	findTrade(message,function(trade){
					    		if(trade != undefined){
					    			var flag = trade.player1.offer != undefined || trade.player2.offer != undefined
					    			if(flag){
						    		trade.confirm(player)
						    		} else {
						    			message.channel.sendMessage("Neither player has offered an item")
						    		}
					    		} else {
					    			message.channel.sendMessage(player.name.capitalize() + " is not currently in a trade!")
					    		}
					    	})
					    }
					    if (input[0]  == "*!custom") {
					    	if(input.length >= 2){
					    		findDuel(message,function(duel){
							     	findTrade(message,function(trade){
							     		if(duel == undefined && trade == undefined){
							     			if(input[1] == "create"){
							     				if(player.custom_weapon == undefined){
							     					if(player.monster_cores >= 5000){
							     						if(player.chaos_fragments >= 5){
									     					if(input[3].toLowerCase() == "melee" || input[3].toLowerCase() == "ranged"){
										     					player.custom_weapon = {
										     						max_damage:350,
										     						custom:true,
										     						souls:0,
																	type: input[3].capitalize(),
																	name: rawinput[2].replace(/_/g," "),
																	level: 1,
																	count: 1,
																	goldToUpgrade: 150,
																	moveDamage: {
																		0: [1, 10],
																		1: [1, 10],
																		2: [1, 10]
																	},
																	effects: []
																}
																player.monster_cores -= 5000
																player.chaos_fragments -= 5
																var finalMessage = "```"
																finalMessage += player.name.capitalize() + " has created " + player.custom_weapon.name.capitalize()
																finalMessage += "```"
																message.channel.sendMessage(finalMessage)
																updatePlayer(player,function(){})
															}
														} else {
															var finalMessage = "```"
															finalMessage += "You need 5000 monster cores and 5 chaos fragments to create a custom weapon!"
															finalMessage += "```"
															message.channel.sendMessage(finalMessage)
														}
													} else {
														var finalMessage = "```"
														finalMessage += "You need 5000 monster cores and 3 chaos fragments to create a custom weapon!"
														finalMessage += "```"
														message.channel.sendMessage(finalMessage)
													}
							     				} else {
														var finalMessage = "```"
														finalMessage += "You already own a custom weapon!"
														finalMessage += "```"
														message.channel.sendMessage(finalMessage)
												}
							     			}
							     			if(input[1] == "remove"){
							     				if(player.custom_weapon != undefined){
							     					player.custom_equipped = false
							     					player.custom_weapon = null
							     					var finalMessage = "```"
													finalMessage += "You have deleted your custom weapon!"
													finalMessage += "```"
													message.channel.sendMessage(finalMessage)
													updatePlayer(player,function(){})
							     				}
							     			}
							     			if(input[1] == "upgrade"){
							     				if(player.custom_weapon){
							     					if(input[2] == "rush" || input[2] == "strike" || input[2] == "counter"){
							     						var damageType = input[2]
							     						input[2] = input[2].replace(/rush/g,"0").replace(/strike/g,"1").replace(/counter/g,"2")
						     							if(player.monster_cores >= 1000){
						     								if(player.custom_weapon.max_damage > 0){
							     								player.monster_cores -= 1000
							     								player.custom_weapon.moveDamage[input[2]][1] += 10
							     								player.custom_weapon.max_damage -= 10
							     								updatePlayer(player,function(){
								     								var finalMessage = "```"
																	finalMessage += "You have upgraded your custom weapon's max " + damageType + " to " + player.custom_weapon.moveDamage[input[2]][1] + " !"
																	finalMessage += "```"
																	message.channel.sendMessage(finalMessage)
																})
							     							} else {
																var finalMessage = "```"
																finalMessage += "Your weapon has reached the damage maximum!"
																finalMessage += "```"
																message.channel.sendMessage(finalMessage)
															}
						     							} else {
															var finalMessage = "```"
															finalMessage += "You need 1000 monster cores to upgrade a custom weapon!"
															finalMessage += "```"
															message.channel.sendMessage(finalMessage)
														}	 
							     					} else {
														var finalMessage = "```"
														finalMessage += "Select a valid damage type to upgrade! \n"
														finalMessage += "Types: rush / strike / counter "
														finalMessage += "```"
														message.channel.sendMessage(finalMessage)
													}
												} else {
													var finalMessage = "```"
													finalMessage += "You do not have a custom weapon! \n"
													finalMessage += "```"
													message.channel.sendMessage(finalMessage)
												}
							     			}
							     			if(input[1] == "downgrade"){
							     				if(player.custom_weapon){
							     					if(input[2] == "rush" || input[2] == "strike" || input[2] == "counter"){
							     						var damageType = input[2]
							     						input[2] = input[2].replace(/rush/g,"0").replace(/strike/g,"1").replace(/counter/g,"2")
							     						if(player.custom_weapon.moveDamage[input[2]][1] >= 0){
						     								player.monster_cores += 500
						     								player.custom_weapon.moveDamage[input[2]][1] -= 10
						     								player.custom_weapon.max_damage += 10
						     								updatePlayer(player,function(){
							     								var finalMessage = "```"
																finalMessage += "You have downgraded your custom weapon's max " + damageType + " to " + player.custom_weapon.moveDamage[input[2]][1] + " !"
																finalMessage += "```"
																message.channel.sendMessage(finalMessage)
							     							})
						     							} else {
															var finalMessage = "```"
															finalMessage += "Your weaponmax damage for " +  player.custom_weapon.moveDamage[input[2]] + " has reached the damage minimum! \n"
															finalMessage += "```"
															message.channel.sendMessage(finalMessage)
														}
							     					} else {
														var finalMessage = "```"
														finalMessage += "Select a valid damage type to upgrade! \n"
														finalMessage += "Types: rush / strike / counter "
														finalMessage += "```"
														message.channel.sendMessage(finalMessage)
													}
												} else {
													var finalMessage = "```"
													finalMessage += "You do not have a custom weapon! \n"
													finalMessage += "```"
													message.channel.sendMessage(finalMessage)
												}
							     			}
							     			if(input[1] == "view"){
							     				if(player.custom_weapon){
								     				message.channel.sendMessage(printWeapon(0,player.custom_weapon))
								     			} else {
													var finalMessage = "```"
													finalMessage += "You do not have a custom weapon! \n"
													finalMessage += "```"
													message.channel.sendMessage(finalMessage)
												}
							     			}
							     			if(input[1] == "equip"){
							     				if(player.custom_weapon){
							     					if(!player.custom_equipped){
								     					player.custom_equipped = true
								     					updatePlayer(player,function(){})
								     					var finalMessage = "```"
														finalMessage += player.name.capitalize() + " has equipped " + player.custom_weapon.name.capitalize() + "! \n"
														finalMessage += "```"
														message.channel.sendMessage(finalMessage)
													} else {
														player.custom_equipped = false
								     					updatePlayer(player,function(){})
								     					var finalMessage = "```"
														finalMessage += player.name.capitalize() + " has unequipped " + player.custom_weapon.name.capitalize() + "! \n"
														finalMessage += "```"
														message.channel.sendMessage(finalMessage)
													}
							     				} else {
													var finalMessage = "```"
													finalMessage += "You do not have a custom weapon! \n"
													finalMessage += "```"
													message.channel.sendMessage(finalMessage)
												}
							     			}
							     		} else {
							     			finalMessage = "```"
											finalMessage += "You cannot complete this action while in a duel or trade! \n"
											finalMessage += "```"
										    message.channel.sendMessage(finalMessage)		
							     		}
							     	})
							    })
					    	} else {
						    	finalMessage = "** *!custom ** \n"
								finalMessage += "```"
								finalMessage += "Function: Manage custom weapons \n"
								finalMessage += "Usage: *!custom (function) \n"
								finalMessage += "Example_1: *!custom create Darkspine77's_Rapier Melee\n"
								finalMessage += "Example_2: *!custom view\n"
								finalMessage += "Example_3: *!custom upgrade strike \n"
								finalMessage += "Example_4: *!custom downgrade strike \n"
								finalMessage += "Example_5: *!custom equip \n"
								finalMessage += "```"
						    	message.channel.sendMessage(finalMessage)
						    }
					    }
					    if (input[0]  == "*!refer") {
					    	if(input.length == 1){
					    		var finalMessage = "```"
								finalMessage += "Have a friend enter in this code after their *!create command to recieve a bonus: " + player.id + "\n"
								finalMessage += "Example: *!create " + player.id + " \n"
								finalMessage += "```"
					    		client.fetchUser(player.id).then(user => 
									user.createDM().then(dm => {
											dm.sendMessage(finalMessage)
										}
									)
								)
					    	}
					    }
					    if (input[0]  == "*!profile") {
					    	if(input.length == 1){
					    		message.channel.sendMessage(printProfile(player))
					    	} else if(input.length == 2){
					    		if(input[1].substring(0,2) == "<@" && input[1].slice(-1) == ">"){
					    			getPlayer(input[1].split("@")[1].replace(">","").replace("!",""),function(player2){
					    				if(player2 != undefined){
				    						message.channel.sendMessage(printProfile(player2))
						    			}	
						    		})
							    } else {
							    	var searchName = input[1].replace(/_/g," ").toLowerCase();
							    	var player_data = firebase.database().ref("players/");
									player_data.once('value').then(function(snapshot) {
										var players = []
										for (id in snapshot.val()) {
											if(searchName == snapshot.val()[id].name.toLowerCase()){
												getPlayer(id,function(player2){
							    					message.channel.sendMessage(printProfile(player2))
									    		})
									    		var finalMessage = "Your profile has been viewed by " + player.name + "!"
									    		client.fetchUser(id).then(user => 
													user.createDM().then(dm => {
															dm.sendMessage(finalMessage)
														}
													)
												)
											}
										};
									})
							    }
						    } else {
						    	finalMessage = "** *!profile ** \n"
								finalMessage += "```"
								finalMessage += "Function: View profile of a player \n"
								finalMessage += "Usage: *!profile (player) \n"
								finalMessage += "Example_1: *!profile \n"
								finalMessage += "Example_2: *!profile @Darkspine77 \n"
								finalMessage += "Example_3: *!profile Biggie_Chee \n"
								finalMessage += "```"
						    	message.channel.sendMessage(finalMessage)
						    }
					    }
					    if(input[0] == "*!party"){
					    	findDuel(message,function(duel){
						     	findTrade(message,function(trade){
						     		if(duel == undefined && trade == undefined){
							     		if(input.length >= 2){
							     			if(input[1] == "create"){
									     		if(player.dungeon == undefined){
									     			var id = "";
														for (var i = 9; i >= 0; i--) {
															id += parseInt(Math.random() * 9)
														}
													var obj = {
														id:id,
														players:[player.id],
														owner:player.id,
														level:player.level
													}
													parties.push(obj)
									     			player.dungeon = id
									     			updatePlayer(player,function(){})
									     			var finalMessage = "```"
													finalMessage += player.name.capitalize() + " has started a party! \n"
													finalMessage += "```"
													message.channel.sendMessage(finalMessage)
								     			} else {
								    				var finalMessage = "```"
													finalMessage += "You are already in a party! \n"
													finalMessage += "```"
												    message.channel.sendMessage(finalMessage)
								    			}	
								     		}
								     		if(input[1] == "list"){
								     			if(player.dungeon != undefined){
									     			getParty(player.dungeon,function(dungeon){
									     				var player_data = firebase.database().ref("players/");
									     				player_data.once('value').then(function(snapshot) {
															var players = snapshot.val()
															var finalMessage = "**Players in " + players[dungeon.owner].name + "'s party:** \n";
															finalMessage += "```"
															for (var i = dungeon.players.length - 1; i >= 0; i--) {
													    		finalMessage += players[dungeon.players[i]].name + " \n"
													    	};
													    	finalMessage += "```"
														})
													    message.channel.sendMessage(finalMessage)
													})
												} else {
													var finalMessage = "```"
													finalMessage += player2.name.capitalize() +" is not in a party! \n"
													finalMessage += "```"
												    message.channel.sendMessage(finalMessage)
												}    
								     		}
								     		if(input[1] == "join"){
								     			if(player.dungeon == undefined){
									     			if(input[2].substring(0,2) == "<@" && input[2].slice(-1) == ">"){
									     				getPlayer(input[2].split("@")[1].replace(">","").replace("!",""),function(player2){
										    				if(player2 != undefined){
									    						if(player2.dungeon != undefined){
									    							player.dungeon = player2.dungeon
									    							var finalMessage = "```"
																	finalMessage += player.name.capitalize() + " has joined " + player2.name.capitalize() + "'s party! \n"
																	finalMessage += "```"
																	updatePlayer(player,function(){
																		getParty(player2.dungeon,function(dungeon){
																			dungeon.players.push(player.id)
																			dungeon.level += player2.level
																			for (var i = dungeon.players.length - 1; i >= 0; i--) {
																		    	client.fetchUser(dungeon.players[i]).then(user => 
																					user.createDM().then(dm => {
																							dm.sendMessage(finalMessage)
																						}
																					)
																				)
																		    };
																		    updateParty(dungeon)
																		})    
																	})
									    						} else {
									    							var finalMessage = "```"
																	finalMessage += player2.name.capitalize() +" is not in a party! \n"
																	finalMessage += "```"
																    message.channel.sendMessage(finalMessage)
									    						}
											    			} else {
											    				var finalMessage = "```"
																finalMessage += "No profile found for this user! \n"
																finalMessage += "```"
															    message.channel.sendMessage(finalMessage)
											    			}	
											    		})
									     			}
									     		} else {
								    				var finalMessage = "```"
													finalMessage += "You are already in a party! \n"
													finalMessage += "```"
												    message.channel.sendMessage(finalMessage)
								    			}	
								     		}
								     		if(input[1] == "leave"){
								     			if(player.dungeon != undefined){
								     				getParty(player.dungeon,function(dungeon){
								     					if(dungeon.players.indexOf(player.id) != -1){
								     						dungeon.players.splice(dungeon.players.indexOf(player.id),1)
								     					}
								     					player.dungeon = null
								     					dungeon.level -= player.level
								     					var leaveMessage = "```"
														leaveMessage += player.name.capitalize() + " left the party! \n"
														leaveMessage += "```"
														updatePlayer(player,function(){})
								     					for (var i = dungeon.players.length - 1; i >= 0; i--) {
								     						client.fetchUser(dungeon.players[i]).then(user => 
																user.createDM().then(dm => {
																		dm.sendMessage(leaveMessage)
																	}
																)
															)
								     					};
								     					if(dungeon.players.length == 0){
								     						deleteParty(dungeon)
								     					} else {
								     						updateParty(dungeon)
								     					}
								     					var finalMessage = "```"
														finalMessage += "You left a dungeon party! \n"
														finalMessage += "```"
													    message.channel.sendMessage(finalMessage)
								     				})
								     			} else {
								     				var finalMessage = "```"
													finalMessage += "You are not in a dungeon party! \n"
													finalMessage += "```"
												    message.channel.sendMessage(finalMessage)
								     			}
								     		}
								     		if(input[1] == "wild"){
								     			if(player.dungeon != undefined){
								     				getParty(player.dungeon,function(dungeon){
								     					if(dungeon.owner == player.id){
								     						generateMob(player,function(enemy){
								     							enemy.id = dungeon.id
								     							enemy.health = Math.ceil(enemy.health * (1 * dungeon.players.length))
								     							enemy.max_health = Math.ceil(enemy.max_health * (1 * dungeon.players.length))
								     							co_op_mobs.push(enemy)
								     							var finalMessage = "```"
														    	finalMessage +="The party was attacked by " + enemy.name + " Lvl " + enemy.level +  "! \n"
														    	finalMessage += "```"
														    	message.channel.sendMessage(finalMessage)
								     							for (var i = dungeon.players.length - 1; i >= 0; i--) {
								     								getPlayer(dungeon.players[i],function(player2){
								     									var newDuel = new Duel(message,player2,enemy,"casual",enemy.expReward,enemy.gold_yield,"bot",false,enemy.id)
													    				duels.push(newDuel)
								     								})
								     							}
								     						})
							     						}
							     					})
							     				}
								     		}
							     		} else {
							     			var finalMessage = "** *!party ** \n"
											finalMessage += "```"
											finalMessage += "Function: Manage parties \n"
											finalMessage += "Usage: *!party (action) \n"
											finalMessage += "Example_1: *!party create\n"
											finalMessage += "Example_2: *!party join @Darkspine77\n"
											finalMessage += "Example_3: *!party leave\n"
											finalMessage += "Example_4: *!party wild\n"
											finalMessage += "Example_5: *!party list\n"
											finalMessage += "```"
											message.channel.sendMessage(finalMessage)
							     		}
							     	}
					     		})
					     	})
					    }
					    if(input[0] == "*!enemy"){
					    	findDuel(message,function(duel){
					    		if(duel != undefined){
					    			if(player.id == duel.player1.player.id){
					    			message.channel.sendMessage(printDuelist(duel.player2))
					    			} else {
					    			message.channel.sendMessage(printDuelist(duel.player1))
					    			}	
					    		} else {
					    			var finalMessage = "```"
									finalMessage += "You are not in a duel \n"
									finalMessage += "```"
								    message.channel.sendMessage(finalMessage)	
					    		}
					    	})
					    }
					    if(input[0] == "*!speak"){
					    	if(input.length >= 2){
					    		var sendMessage = player.name + ": " + message.content.split(player.prefix + "speak ")[1]
					    		if(sendMessage == undefined){
					    			sendMessage = player.name + ": " + message.content.split("*!speak ")[1]
					    		}
						    	findDuel(message,function(duel){
						    		findTrade(message,function(trade){
							    		if(duel != undefined){
							    			duel.dmPlayers(sendMessage)
							    		} else if (player.spectating != null){
							    			for (var i = duels.length - 1; i >= 0; i--) {
							    				if(duels[i].id == player.spectating){
							    					duels[i].dmPlayers(sendMessage)
							    				}
							    			};
							    		} else if (trade != undefined){
							    			trade.dmPlayers(sendMessage)
							    		} else {
							    			var finalMessage = "```"
											finalMessage += player.name + " is not in a duel or spectating! \n"
											finalMessage += "```"
										    message.channel.sendMessage(finalMessage)	
							    		}
						    		})
						    	})
						    } else {
						    	var finalMessage = "** *!speak ** \n"
								finalMessage += "```"
								finalMessage += "Function: Talk to people in a duel \n"
								finalMessage += "Usage: *!speak (message) \n"
								finalMessage += "Example: *!speak Nice Shot!\n"
								finalMessage += "```"
						    	message.channel.sendMessage(finalMessage)
						    }
					    }
					    if(input[0] == "*!endspectate"){
					    	if(input.length == 1){
					    		if(player.spectating != undefined){
					    			getDuel(player.spectating,function(duel){
							    		for (var i = duel.spectators.length - 1; i >= 0; i--) {
							    		 	if(duel.spectators[i].id == player.id){
							    		 		duel.spectators.splice(i,1)
							    		 		var finalMessage = "```"
												finalMessage += player.name + " is no longer spectating a duel! \n"
												finalMessage += "```"
											    message.channel.sendMessage(finalMessage)	
							    		 		player.spectating = null
							    		 		updatePlayer(player,function(){})
							    		 	}
							    		}; 
						    		})
						    	} else {
						    		var finalMessage = "```"
									finalMessage += player.name + " is not spectating! \n"
									finalMessage += "```"
								    message.channel.sendMessage(finalMessage)
						    	}
						    }
					    }
					    if (input[0] == "*!spectate") {
					     	if(player.spectating == null) {
						     	findDuel(message,function(duel){
						     		findTrade(message,function(trade){
						     			if(duel == undefined && trade == undefined){
									    	if(input.length == 2){
									    		if(input[1].substring(0,2) == "<@" && input[1].slice(-1) == ">"){
										    		getPlayer(input[1].split("@")[1].replace(">","").replace("!",""),function(player2){
										    			var message2 = {
							    							fake: true,
							    							id: player2.id,
							    							spectating:true
							    						}
										    			findDuel(message2,function(duel2){
										    				if(duel2 != undefined){
										    					var spectator = {
										    						id:player.id,
										    					}
										    					duel2.spectators.push(spectator)
										    					finalMessage = "```"
																finalMessage += player.name + " is now spectating " + player2.name + "! \n"
																finalMessage += "```"
															    duel2.dmPlayers(finalMessage)	
															    player.spectating = duel2.id
															    updatePlayer(player,function(){})
										    				} else {
									    						finalMessage = "```"
																finalMessage += player2.name + " is not in a duel! \n"
																finalMessage += "```"
															    message.channel.sendMessage(finalMessage)	
										    				}
										    			})
										    		})
										    	} else {
										    		var searchName = input[1].replace(/_/g," ").toLowerCase();
											    	var player_data = firebase.database().ref("players/");
													player_data.once('value').then(function(snapshot) {
														var players = []
														for (id in snapshot.val()) {
															if(searchName == snapshot.val()[id].name.toLowerCase()){
																var player2 = snapshot.val()[id]
																var message2 = {
									    							fake: true,
									    							id: player2.id,
							    									spectating:true
									    						}
												    			findDuel(message2,function(duel2){
												    				if(duel2 != undefined){
												    					var spectator = {
												    						id:player.id
												    					}
												    					duel2.spectators.push(spectator)
												    					finalMessage = "```"
																		finalMessage += player.name + " is now spectating " + player2.name + "! \n"
																		finalMessage += "```"
																	    duel2.dmPlayers(finalMessage)
																	    player.spectating = duel2.id
																	    updatePlayer(player,function(){})
												    				} else {
											    						finalMessage = "```"
																		finalMessage += player2.name + " is not in a duel! \n"
																		finalMessage += "```"
																	    message.channel.sendMessage(finalMessage)	
												    				}
												    			})
															}
														};
													})
										    	}
									    	} else {
									    		finalMessage = "** *!spectate** \n"
												finalMessage += "```"
												finalMessage += "Function: Spectate a duel \n"
												finalMessage += "Usage: *!spectate (player) \n"
												finalMessage += "Example_1: *!spectate @Darkspine77\n"
												finalMessage += "Example_2: *!spectate Darkspine77\n"
												finalMessage += "```"
										    	message.channel.sendMessage(finalMessage)
									    	}
									    } else { 
									    	finalMessage = "```"
											finalMessage += "You cannot complete this action while in a duel or trade! \n"
											finalMessage += "```"
										    message.channel.sendMessage(finalMessage)	
									    }
						    		})
						     	})
							} else {
								player.spectating == null
								updatePlayer(player,function(result){
									finalMessage = "```"
									finalMessage += "You are no longer spectating! \n"
									finalMessage += "```"
									message.channel.sendMessage(finalMessage)	
								})
							}
					    }
					    if (input[0]  == "*!inventory") {
					    	if(input.length == 1) {
					    		var invtext = printInventory(player.inventory)
					    		invtext = invtext.reverse()
					    		for (var i = invtext.length - 1; i >= 0; i--) {
					    			message.channel.sendMessage(invtext[i])
					    		};
						    	
						    } else {
						    	finalMessage = "** *!inventory ** \n"
								finalMessage += "```"
								finalMessage += "Function: View inventory \n"
								finalMessage += "Usage: *!inventory \n"
								finalMessage += "Example: *!inventory \n"
								finalMessage += "```"
						    	message.channel.sendMessage(finalMessage)
						    }
					    }
					    if(input[0] == "*!help" && input.length == 1){
							message.channel.sendMessage("Check your private messages")
							finalMessage = getHelpText()
							client.fetchUser(String(message.author.id)).then(user => 
								user.createDM().then(dm => {
											dm.sendMessage(finalMessage)
										}
									)
								)
						}
					    if (input[0]  == "*!shop") {
					    	if(input.length == 1){
						    	message.channel.sendMessage(printShop())
						    } else {
						    	finalMessage = "** *!shop ** \n"
								finalMessage += "```"
								finalMessage += "Function: View shop \n"
								finalMessage += "Usage: *!shop \n"
								finalMessage += "Example: *!shop \n"
								finalMessage += "```"
						    	message.channel.sendMessage(finalMessage)	
						    }
					    }
					    if (input[0] == "*!buylife") {
					    	findDuel(message,function(duel){
					    		findTrade(message,function(trade){
					    			if(duel == undefined && trade == undefined){
					    				if(input.length == 1){
					    					if(player.gold >= 1200 && player.monster_cores >= 100){
					    						if(player.lives < 20){
						    						player.confirming = "newlife"
						    						var finalMessage = "```"
											    	finalMessage += "Are you sure you would like to spend 1200 gold and 100 monster cores to buy an extra life? \n \n"
											    	finalMessage += "Type *!yes to confirm or *!no to cancel \n"
												   	finalMessage += "```"
											   		updatePlayer(player,function(){
												   		message.channel.sendMessage(finalMessage)	
											   		})
											   	} else {
											   		message.channel.sendMessage("You can only have a max of 20 lives!")
											   	}
					    					} else {
					    						message.channel.sendMessage("You need " + (1200 - player.gold) + " more gold and " + (100 - player.monster_cores) + " more monster cores to purchase an extra life!")
					    					}
					    				}
					    			}
					    		})
					    	})
					    }
					    if (input[0] == "*!buy") {
					    		findDuel(message,function(duel){
					    			findTrade(message,function(trade){
					    				if(duel == undefined && trade == undefined){
									    	if(input.length == 3){
									    		if(parseInt(input[2]) <= 20 && parseInt(input[2]) >= 1 ){
											    	var inventory = []
											    	input[1] -= 1
													for (var i = data.weapons.length - 1; i >= 0; i--) {
														if(data.weapons[i].cost != undefined){
															inventory.push(data.weapons[i])
														}
													}
											    	if(inventory[input[1]].cost * parseInt(input[2]) <= player.gold) {
											    		player.selectedAmount = parseInt(input[2])
												    	player.confirming = "purchase"
												    	var obj = {
												    		name: inventory[input[1]].name,
												    		cost: inventory[input[1]].cost,
												    		count: parseInt(input[2])
												    	}
												    	if(inventory[input[1]].level != undefined){
												    		obj.level = 1
												    		obj.goldToUpgrade = inventory[input[1]].goldToUpgrade
												    	}
												    	if(inventory[input[1]].item_id != undefined){
												    		obj.item_id = inventory[input[1]].item_id
												    		obj.useEffect = inventory[input[1]].useEffect
												    		obj.modifier = inventory[input[1]].modifier
												    	}
												    	player.desiredPurchase = obj
												    	var finalMessage = "```"
												    	finalMessage += "Are you sure you would like to spend " + (player.desiredPurchase.cost) * player.selectedAmount + " gold to buy " + player.desiredPurchase.count + " " + player.desiredPurchase.name + "? \n \n"
												    	finalMessage += "Type *!yes to confirm or *!no to cancel \n"
												    	finalMessage += "```"
												    	updatePlayer(player,function(){
												    		message.channel.sendMessage(finalMessage)	
												    	})
												    } else {
												    	message.channel.sendMessage("You need " + ((inventory[input[1]].cost * parseInt(input[2]) - player.gold)) + " more gold to purchase that item!")
												    }
												} else {
													var finalMessage = "```"
												   	finalMessage += "You may only buy a maximum of 20 and a minimum of 1 of an item\n"
												   	finalMessage += "```"
												   	message.channel.sendMessage(finalMessage)
												}
											} else {
												finalMessage = "** *!buy ** \n"
												finalMessage += "```"
												finalMessage += "Function: Buy an item from the shop \n"
												finalMessage += "Usage: *!buy (shop index) (amount) \n"
												finalMessage += "Example: *!buy 1 1 \n"
												finalMessage += "```"
										    	message.channel.sendMessage(finalMessage)		
											}
										} else {
											finalMessage = "```"
										finalMessage += "You cannot complete this action while in a duel or trade! \n"
										finalMessage += "```"
									    message.channel.sendMessage(finalMessage)		
										}
									})
						    	})
							}
						if (input[0]  == "*!quests") {
							findDuel(message,function(duel){
					    		findTrade(message,function(trade){
					    			if(duel == undefined && trade == undefined){
					    				if(player.quest_id == 0){
					    					finalMessage = "__**Erradicator**__"
					    					finalMessage += "```"
											finalMessage += "Kill " + player.quest_counter + "/" + player.quest_goal + " creatures from wild duels\n"
											finalMessage += "```"
										    message.channel.sendMessage(finalMessage)	
					    				}
					    				if(player.quest_id == 1){
					    					finalMessage = "__**Brutalizer**__"
					    					finalMessage += "```"
											finalMessage += "Deal " + player.quest_counter + "/" +  player.quest_goal + " damage to enemies\n"
											finalMessage += "```"
										    message.channel.sendMessage(finalMessage)	
					    				}
					    				if(player.quest_id == 2){
					    					finalMessage = "__**Premeditated Victor**__"
					    					finalMessage += "```"
											finalMessage += "Succede " + player.quest_counter + "/" +  player.quest_goal + " rounds\n"
											finalMessage += "```"
										    message.channel.sendMessage(finalMessage)	
					    				}
					    				if(player.quest_id == 3){
					    					finalMessage = "__**Not Exactly Charasmatic**__"
					    					finalMessage += "```"
											finalMessage += "Kill " + player.quest_counter + "/" +  player.quest_goal + " players in PVP duels\n"
											finalMessage += "```"
										    message.channel.sendMessage(finalMessage)	
					    				}
					    				if(player.quest_id == 4){
					    					finalMessage = "__**Battle Worn**__"
					    					finalMessage += "```"
											finalMessage += "Take " + player.quest_counter + "/" +  player.quest_goal + " damage\n"
											finalMessage += "```"
										    message.channel.sendMessage(finalMessage)	
					    				}
					    			}
					    		})
					    	})
						}
					    if (input[0]  == "*!equip") {
					    	findDuel(message,function(duel){
					    		findTrade(message,function(trade){
					    			if(duel == undefined && trade == undefined){
								    	if(input.length == 2){
								    		if(player.inventory[input[1] - 1] != undefined){ 
										    	if(player.inventory[input[1] - 1].level != undefined){
										    		if(player.inventory[input[1] - 1].level <= player.level){
											    		player.selectedItemIndex = input[1] - 1
											    		player.confirming = "equip"
											    		var finalMessage = "```"
												    	finalMessage += "Are you sure you would like to equip " + player.inventory[player.selectedItemIndex].name + " as your primary weapon? \n \n"
												    	finalMessage += "Type *!yes to confirm or *!no to cancel \n"
												    	finalMessage += "```"
												    	updatePlayer(player,function(){
												    		message.channel.sendMessage(finalMessage)	
												    	})
												    } else {
														finalMessage = "```"
														finalMessage += "You can not equip a weapon that is higher leveled than you! \n"
														finalMessage += "```"
														message.channel.sendMessage(finalMessage)
												    }
										    	}
										    }
									    } else {
									    	finalMessage = "** *!equip ** \n"
											finalMessage += "```"
											finalMessage += "Function: Equip an item as your primary weapon \n"
											finalMessage += "Usage: *!equip (inventory index) \n"
											finalMessage += "Example: *!equip 1 \n"
											finalMessage += "```"
									    	message.channel.sendMessage(finalMessage)		
									    }		
						    		} else {
						    			finalMessage = "```"
										finalMessage += "You cannot complete this action while in a duel or trade! \n"
										finalMessage += "```"
									    message.channel.sendMessage(finalMessage)		
						    		}
								})
						    })
					    }
					    if (input[0]  == "*!heal"){
					    	findDuel(message,function(duel){
					    		findTrade(message,function(trade){
						    		if(duel == undefined && trade == undefined){
						    			if(player.health != player.max_health){
							    			if(player.gold >= Math.ceil((player.max_health * .33) * player.level/4.5)){
							    				var cost = Math.ceil((player.max_health * .33) * player.level/4.5)
							    				player.gold -= cost
							    				player.health += Math.ceil(player.max_health * 0.33)
							    				if(player.health > player.max_health){
							    					player.health = player.max_health
							    				}
							    				updatePlayer(player,function(){
							    					finalMessage = "```"
													finalMessage += player.name.capitalize() + " recovered " + Math.ceil(player.max_health * 0.33) + " health for " + Math.ceil((player.max_health * .33) * player.level/6.5) + " gold! \n"
													finalMessage += "```"
												    message.channel.sendMessage(finalMessage)	
							    				})
							    			} else {
							    				finalMessage = "```"
												finalMessage += "You need " + Math.ceil((player.max_health * .33) * player.level/6.5) + " gold to heal! \n"
												finalMessage += "```"
											    message.channel.sendMessage(finalMessage)
							    			}
							    		} else {
							    			finalMessage = "```"
											finalMessage += "You are at full health! \n"
											finalMessage += "```"
										    message.channel.sendMessage(finalMessage)	
							    		}
						    		}
						    	})
						    })
					    }
					    if (input[0]  == "*!use") {
					    	findDuel(message,function(duel){
					    		findTrade(message,function(trade){
						    		if(duel == undefined && trade == undefined){
								    	if(input.length == 3){
								    		player.selectedItemIndex = input[1] - 1
								    		if(player.inventory[player.selectedItemIndex] != undefined){
										    	if(player.inventory[player.selectedItemIndex].useEffect != undefined){
										    		if(player.inventory[player.selectedItemIndex].count >= parseInt(input[2])){
											    		player.selectedAmount = parseInt(input[2])
											    		player.confirming = "use"
											    		var finalMessage = "```"
												    	finalMessage += "Are you sure you would use " + player.selectedAmount + " " + player.inventory[player.selectedItemIndex].name + "? \n \n"
												    	finalMessage += "Type *!yes to confirm or *!no to cancel \n"
												    	finalMessage += "```"
												    	updatePlayer(player,function(){
												    		message.channel.sendMessage(finalMessage)	
												    	})
												    } else {
												    	message.channel.sendMessage("You do not have " + player.selectedAmount + " " + player.inventory[player.selectedItemIndex].name + "!")
												    }
												}
									    	}
									    } else {
									    	finalMessage = "** *!use ** \n"
											finalMessage += "```"
											finalMessage += "Function: Use an item \n"
											finalMessage += "Usage: *!use (inventory index) (amount) \n"
											finalMessage += "Example: *!use 1 1 \n"
											finalMessage += "```"
									    	message.channel.sendMessage(finalMessage)		
									    }
									} else {
										finalMessage = "```"
										finalMessage += "You cannot complete this action while in a duel or trade! \n"
										finalMessage += "```"
									    message.channel.sendMessage(finalMessage)		
									}
								})
							})
					    }
					    if (input[0]  == "*!combos") {
					    	findDuel(message,function(duel){
					    		findTrade(message,function(trade){
						    		if(duel == undefined && trade == undefined){
							    		if(input[1] == "create"){
							    			if(player.combos == undefined || player.combos.length <= 3){
							    				if(player.combos == undefined){
							    					player.combos = []
							    				}
								    			if(input.length == 5){
									    			if(input[3].split("-").length == 3){
									    				var recipeInput = input[3].replace(/rush/g,"0").replace(/strike/g,"1").replace(/counter/g,"2").split("-")
									    				var recipeOutput = [parseInt(recipeInput[0]),parseInt(recipeInput[1]),parseInt(recipeInput[2])]
									    				if (recipeOutput.length == 3) {
									    					if(input[4].toLowerCase() == "damage" || input[4].toLowerCase() == "heal" || input[4].toLowerCase() == "evade" || input[4].toLowerCase() == "resist"){
									    						var overlapRecipe = false
									    						var overlapName = false
									    						var overlapType = false
									    						for (var i = player.combos.length - 1; i >= 0; i--) {
									    							if(player.combos[i].recipe == recipeOutput){
									    								overlapRecipe = true
									    							}
									    						};
									    						for (var i = player.combos.length - 1; i >= 0; i--) {
									    							if(player.combos[i].name == input[2].replace(/_/g," ")){
									    								overlapName = true
									    							}
									    						};
									    						for (var i = player.combos.length - 1; i >= 0; i--) {
									    							if(player.combos[i].stat_modify == input[4].toLowerCase()){
									    								overlapType = true
									    							}
									    						};
									    						if(!overlapType){
									    							if(!overlapName){
									    								if(!overlapRecipe){
												    						var baseAmount;
												    						if(input[4].toLowerCase() == "damage"){
												    							baseAmount = .2
												    						}
												    						if(input[4].toLowerCase() == "heal"){
												    							baseAmount = .02
												    						}
												    						if(input[4].toLowerCase() == "evade"){
												    							baseAmount = 16
												    						}
												    						if(input[4].toLowerCase() == "resist"){
												    							baseAmount = .10
												    						}
												    						var newCombo = {
																				name: input[2].replace(/_/g," "),
																				recipe: recipeOutput,
																				recipe_string: input[3].toLowerCase(),
																				stat_modify: input[4].toLowerCase(),
																				amount: baseAmount,
																				level:1
															    			}
															    			if(player.combos == undefined){
															    				player.combos = []
															    			}
															    			player.combos.push(newCombo)
																		    updatePlayer(player,function(){
																			   	finalMessage = "```"
																				finalMessage += player.name + "created the combo: " + newCombo.name + "! \n"
																				finalMessage += "```"
																			    message.channel.sendMessage(finalMessage)
																		    })
																		} else {
											    					finalMessage = "```"
																	finalMessage += "Duplicate recipes are not allowed! \n"
																	finalMessage += "```"
																    message.channel.sendMessage(finalMessage)
											    						}
																	} else {
											    					finalMessage = "```"
																	finalMessage += "Duplicate names are not allowed! \n"
																	finalMessage += "```"
																    message.channel.sendMessage(finalMessage)
											    						}
																	} else {
											    					finalMessage = "```"
																	finalMessage += "Duplicate combo types are not allowed! \n"
																	finalMessage += "```"
																    message.channel.sendMessage(finalMessage)
											    				}
									    					} else {
									    						finalMessage = "```"
																finalMessage += "Invalid Effect! \n"
																finalMessage += "Valid Effects: (damage) (heal) (evade) (resist) \n"
																finalMessage += "```"
															    message.channel.sendMessage(finalMessage)
									    					}
									    				} else {
									    					finalMessage = "```"
															finalMessage += "Invalid Recipe! \n"
															finalMessage += "Valid Recipe: strike-rush-counter \n"
															finalMessage += "```"
														    message.channel.sendMessage(finalMessage)
									    				}
									    			} else {
									    				finalMessage = "```"
														finalMessage += "Invalid Recipe! \n"
														finalMessage += "Valid Recipe: strike-rush-counter \n"
														finalMessage += "```"
													    message.channel.sendMessage(finalMessage)
									    			} 
										    	} else {
										    		finalMessage = "** *!combos ** \n"
													finalMessage += "```"
													finalMessage += "Function: Manage combos \n"
													finalMessage += "Usage: *!combos (intent)\n"
													finalMessage += "Example_1: *!combos create Super_Attack strike-strike-strike damage \n"
													finalMessage += "Example_2: *!combos upgrade 1 \n"
													finalMessage += "Example_3: *!combos view 1 \n"
													finalMessage += "Example_4: *!combos remove 1  \n"
													finalMessage += "Example_5: *!combos list  \n"
													finalMessage += "```"
											    	message.channel.sendMessage(finalMessage)	
										    	}
										    } else {
										    	finalMessage = "```"
												finalMessage += "You have reached the maximum number of combos! \n"
												finalMessage += "```"
											    message.channel.sendMessage(finalMessage)
										    }
								    	} else if(input[1] == "upgrade"){
								    		if(input.length == 3){
								    			var i = input[2] - 1
								    			if(player.combos != undefined){
									    			if(player.combos[i] != undefined) {
									    					if(player.gold >= player.combos[i].level * 300){
									    						if(player.combos[i].level < 5){
											    					player.confirming = "comboUpgrade"
											    					player.comboIndex = i
											    					var finalMessage = "```"
															    	finalMessage += "Are you sure you would like to upgrade " + player.combos[i].name + " to level " + (player.combos[i].level + 1) + "? \n \n"
															    	finalMessage += "It will cost " + player.combos[i].level * 150 - player.gold + " gold. \n"
															    	finalMessage += "Type *!yes to confirm or *!no to cancel \n"
															    	finalMessage += "```"
																   	updatePlayer(player,function(){
																   		message.channel.sendMessage(finalMessage)	
																    })
																} else {
																	finalMessage = "```"
																	finalMessage += "That combo is already at max level! \n"
																	finalMessage += "```"
																    message.channel.sendMessage(finalMessage)
																}
															} else {
																message.channel.sendMessage("You need " + ((player.combos[i].level * 150 - player.gold) + " more gold to upgrade that combo!"))
															}
									    			} else {
									    				finalMessage = "```"
														finalMessage += "No combo found at combo slot #" + input[2] + " \n"
														finalMessage += "```"
													    message.channel.sendMessage(finalMessage)
									    			}
									    		} else {
									    			finalMessage = "```"
										    		finalMessage += "No combos found for this player \n"
										    		finalMessage += "```"
										    		message.channel.sendMessage(finalMessage)
										    	}
								    		} else {
								    			finalMessage = "** *!combos ** \n"
												finalMessage += "```"
												finalMessage += "Function: Manage combos \n"
												finalMessage += "Usage: *!combos (intent)\n"
												finalMessage += "Example_1: *!combos create Super_Attack strike-strike-strike damage\n"
												finalMessage += "Combo Types: damage / heal / resist / evade \n"
												finalMessage += "Example_2: *!combos upgrade 1 \n"
												finalMessage += "Example_3: *!combos view 1 \n"
												finalMessage += "Example_4: *!combos remove 1  \n"
												finalMessage += "Example_5: *!combos list  \n"
												finalMessage += "```"
										    	message.channel.sendMessage(finalMessage)
								    		}
								    	} else if(input[1] == "view"){
								    		if(input.length == 3){
									    		var i = input[2] - 1
									    		if(player.combos != undefined){
										    		if(player.combos[i] != undefined) {
										    			message.channel.sendMessage(printCombo(player.combos[i]))
										    		} else {
										    			finalMessage = "```"
														finalMessage += "No combo found at combo slot #" + input[2] + " \n"
														finalMessage += "```"
													    message.channel.sendMessage(finalMessage)
										    		}
										    	} else {
									    			finalMessage = "```"
										    		finalMessage += "No combos found for this player \n"
										    		finalMessage += "```"
										    		message.channel.sendMessage(finalMessage)
										    	}
									    	} else {
									    		finalMessage = "** *!combos ** \n"
												finalMessage += "```"
												finalMessage += "Function: Manage combos \n"
												finalMessage += "Usage: *!combos (intent)\n"
												finalMessage += "Example_1: *!combos create Super_Attack strike-strike-strike damage\n"
												finalMessage += "Combo Types: damage / heal / resist / evade \n"
												finalMessage += "Example_2: *!combos upgrade 1 \n"
												finalMessage += "Example_3: *!combos view 1 \n"
												finalMessage += "Example_4: *!combos remove 1  \n"
												finalMessage += "Example_5: *!combos list  \n"
												finalMessage += "```"
										    	message.channel.sendMessage(finalMessage)
									    	}
								    	} else if(input[1] == "list"){
								    		if(input.length == 2){
								    			finalMessage = "```"
									    		if(player.combos != undefined){
										    		for (var i = player.combos.length - 1; i >= 0; i--) {
										    			finalMessage += "#" + (i + 1) + " - " + player.combos[i].name + " \n"
										    		};
										    		finalMessage += "```"
										    	} else {
										    		finalMessage += "No combos found for this player \n"
										    		finalMessage += "```"
										    	}
									    		message.channel.sendMessage(finalMessage)
									    	} else {
									    		finalMessage = "** *!combos ** \n"
												finalMessage += "```"
												finalMessage += "Function: Manage combos \n"
												finalMessage += "Usage: *!combos (intent)\n"
												finalMessage += "Example_1: *!combos create Super_Attack strike-strike-strike damage\n"
												finalMessage += "Combo Types: damage / heal / resist / evade \n"
												finalMessage += "Example_2: *!combos upgrade 1 \n"
												finalMessage += "Example_3: *!combos view 1 \n"
												finalMessage += "Example_4: *!combos remove 1  \n"
												finalMessage += "Example_5: *!combos list  \n"
												finalMessage += "```"
										    	message.channel.sendMessage(finalMessage)
									    	}
								    	} else if(input[1] == "remove"){
								    		if(input.length == 3){
								    			var i = input[2] - 1
								    			if(player.combos != undefined){
									    			if(player.combos[i] != undefined) {
									    					player.confirming = "comboRemove"
									    					player.comboIndex = i
									    					var finalMessage = "```"
													    	finalMessage += "Are you sure you would like to remove " + player.combos[i].name + "? \n \n"
													    	finalMessage += "Type *!yes to confirm or *!no to cancel \n"
													    	finalMessage += "```"
														   	updatePlayer(player,function(){
														   		message.channel.sendMessage(finalMessage)	
														    })
									    			} else {
									    				finalMessage = "```"
														finalMessage += "No combo found at combo slot #" + input[2] + " \n"
														finalMessage += "```"
													    message.channel.sendMessage(finalMessage)
									    			}
									    		} else {
									    			finalMessage = "```"
										    		finalMessage += "No combos found for this player \n"
										    		finalMessage += "```"
										    		message.channel.sendMessage(finalMessage)
										    	}
								    		} else {
								    			finalMessage = "** *!combos ** \n"
												finalMessage += "```"
												finalMessage += "Function: Manage combos \n"
												finalMessage += "Usage: *!combos (intent)\n"
												finalMessage += "Example_1: *!combos create Super_Attack strike-strike-strike damage\n"
												finalMessage += "Combo Types: damage / heal / resist / evade \n"
												finalMessage += "Example_2: *!combos upgrade 1 \n"
												finalMessage += "Example_3: *!combos view 1 \n"
												finalMessage += "Example_4: *!combos remove 1  \n"
												finalMessage += "Example_5: *!combos list  \n"
												finalMessage += "```"
										    	message.channel.sendMessage(finalMessage)
								    		}
								    	} else { 
								    			finalMessage = "** *!combos ** \n"
												finalMessage += "```"
												finalMessage += "Function: Manage combos \n"
												finalMessage += "Usage: *!combos (intent)\n"
												finalMessage += "Example_1: *!combos create Super_Attack strike-strike-strike damage\n"
												finalMessage += "Combo Types: damage / heal / resist / evade \n"
												finalMessage += "Example_2: *!combos upgrade 1 \n"
												finalMessage += "Example_3: *!combos view 1 \n"
												finalMessage += "Example_4: *!combos remove 1  \n"
												finalMessage += "Example_5: *!combos list  \n"
												finalMessage += "```"
										    	message.channel.sendMessage(finalMessage)
								    	}
								    } else {
											finalMessage = "```"
										finalMessage += "You cannot complete this action while in a duel or trade! \n"
										finalMessage += "```"
									    message.channel.sendMessage(finalMessage)		
									}
								})
					    	})
					    }
					    if (input[0]  == "*!sell") {
					    		findDuel(message,function(duel){
					    			findTrade(message,function(trade){
					    				if(trade == undefined && duel == undefined){
									    	if(input.length == 3){
									    		player.selectedItemIndex = input[1] - 1
									    		if(player.inventory != undefined){
										    		if(player.inventory[player.selectedItemIndex] != undefined){
											    		if(player.inventory[player.selectedItemIndex].count >= parseInt(input[2])){
												    		player.selectedAmount = parseInt(input[2])
												    		player.confirming = "sell"
												    		var finalMessage = "```"
													    	finalMessage += "Are you sure you would sell " + player.selectedAmount + " " + player.inventory[player.selectedItemIndex].name + "? \n \n"
													    	var goldGained = 0;
												    		if(player.inventory[player.selectedItemIndex].cost != undefined){
												    			goldGained = parseInt(player.inventory[player.selectedItemIndex].cost * .7)
												    		}
												    		if(player.inventory[player.selectedItemIndex].sellValue != undefined){
												    			goldGained = player.inventory[player.selectedItemIndex].sellValue
												    		}
												    		if(goldGained == 0){
												    			goldGained = player.inventory[player.selectedItemIndex].goldToUpgrade * 0.5
												    		}
												    		goldGained *= player.selectedAmount
													    	finalMessage += "You will recieve " + parseInt(goldGained) + " gold \n \n"
														   	finalMessage += "Type *!yes to confirm or *!no to cancel \n"
														   	finalMessage += "```"
														   	updatePlayer(player,function(){
														   		message.channel.sendMessage(finalMessage)	
														    })
													    } else {
													    	message.channel.sendMessage("You do not have " + parseInt(input[2]) + " " + player.inventory[player.selectedItemIndex].name + "!")
													    }
													} else {
														message.channel.sendMessage("No item found at invetory slot " + input[1] + "!")
													}
												} else {
													var finalMessage = "```"
													finalMessage += "No items found in this players inventory \n"
													finalMessage += "```"	
													message.channel.sendMessage(finalMessage)
												}
										    } else {
										    	finalMessage = "** *!sell ** \n"
												finalMessage += "```"
												finalMessage += "Function: Sell an item \n"
												finalMessage += "Usage: *!sell (inventory index) (amount)\n"
												finalMessage += "Example: *!sell 1 1 \n"
												finalMessage += "```"
										    	message.channel.sendMessage(finalMessage)		
										    }
										} else {
											finalMessage = "```"
										finalMessage += "You cannot complete this action while in a duel or trade! \n"
										finalMessage += "```"
									    message.channel.sendMessage(finalMessage)		
										}
						    	})
					    	})
					    }
					    if (input[0]  == "*!upgrade" && input.length == 1) {
					    		findDuel(message,function(duel){
					    			findTrade(message,function(trade){
					    				if(duel == undefined && trade == undefined) {
									    	player.confirming = "upgrade"
									    	if(!player.custom_equipped){
										    	if(player.weapon.level < 30){
										    		if(player.weapon.level < player.level){
												    	if(parseInt(player.weapon.goldToUpgrade * player.weapon.level) <= player.gold){
													    	var finalMessage = "```"
														    	finalMessage += "Are you sure you would like to upgrade " + player.weapon.name + " to level " + (player.weapon.level + 1) + "? \n \n"
														    	finalMessage += "It will cost " + parseInt(player.weapon.goldToUpgrade * player.weapon.level) + " gold \n \n"
														    	finalMessage += "Type *!yes to confirm or *!no to cancel \n"
														    	finalMessage += "```"
														   	updatePlayer(player,function(){
														   		message.channel.sendMessage(finalMessage)	
														    })
													   } else {
													   		message.channel.sendMessage("You need " + ((player.weapon.goldToUpgrade * player.weapon.level) - player.gold) + " more gold to upgrade that item!")
													   }
													} else {
														message.channel.sendMessage("You can not wield weapons that are a higher level than your player!")
													}
												} else {
													message.channel.sendMessage("Your weapon is at max level!")
												}
											} else {
												if(player.custom_weapon.level < 30){
													if(player.weapon.level <= player.level){
												    	if(parseInt(player.custom_weapon.goldToUpgrade * player.custom_weapon.level) <= player.gold){
													    	var finalMessage = "```"
														    	finalMessage += "Are you sure you would like to upgrade " + player.custom_weapon.name + " to level " + (player.custom_weapon.level + 1) + "? \n \n"
														    	finalMessage += "It will cost " + parseInt(player.custom_weapon.goldToUpgrade * player.custom_weapon.level) + " gold \n \n"
														    	finalMessage += "Type *!yes to confirm or *!no to cancel \n"
														    	finalMessage += "```"
														   	updatePlayer(player,function(){
														   		message.channel.sendMessage(finalMessage)	
														    })
													   } else {
													   		message.channel.sendMessage("You need " + ((player.custom_weapon.goldToUpgrade * player.custom_weapon.level) - player.gold) + " more gold to upgrade that item!")
													   }
													} else {
														message.channel.sendMessage("You can not wield weapons that are a higher level than your player!")
													}
												} else {
													message.channel.sendMessage("Your weapon is at max level!")
												}
											}
									} else {
											finalMessage = "```"
										finalMessage += "You cannot complete this action while in a duel or trade! \n"
										finalMessage += "```"
									    message.channel.sendMessage(finalMessage)		
									}
								})
							})
					    }
					    if(input[0] == "*!skillreset"){
					    	if(input.length == 1){
						    		findDuel(message,function(duel){
						    			findTrade(message,function(trade){
						    				if(duel == undefined && trade == undefined) {
						    					player.confirming = "skillreset"
						    					var cost = 100 * (player.skillpoints.strength + player.skillpoints.speed + player.skillpoints.perception)
						    					if(player.gold >= cost){
							    					var finalMessage = "```"
													    	finalMessage += "Are you sure you would like to reset all skill points? \n \n"
													    	finalMessage += "It will cost " + cost + " gold \n \n"
													    	finalMessage += "Type *!yes to confirm or *!no to cancel\n"
													    	finalMessage += "```"
												   	updatePlayer(player,function(){
												   		message.channel.sendMessage(finalMessage)	
												    })
												} else {
													message.channel.sendMessage("You need " + (cost - player.gold) + " more gold to reset your skills!")
												}
						  					} else {
												finalMessage = "```"
												finalMessage += "You cannot complete this action while in a duel or trade! \n"
												finalMessage += "```"
											    message.channel.sendMessage(finalMessage)		
										}
									})
								})
							}
					    }
					    if (input[0]  == "*!keystone") {
					    	if(input.length >= 2){
						    		findDuel(message,function(duel){
						    			findTrade(message,function(trade){
						    				if(duel == undefined && trade == undefined) {
						    					if(input[1] == "add"){
						    						if (player.keystones[input[2]] == -1 && player.keystones.assigned < 4 && player.keystones.points_availible > 0) {
						    							player.keystones[input[2]] = 1
						    							player.keystones.assigned += 1
						    							player.keystones.points_availible -= 1
						    							finalMessage = "```"
														finalMessage += player.name + " has added " + input[2] + " to their keystones! \n"
														finalMessage += "```"
														// player.bonus_health = (75 * player.keystones.hearty_warrior)
														updatePlayer(player,function(){
															message.channel.sendMessage(finalMessage)	
														})
						    						} else {
														finalMessage = "```"
														finalMessage += "Either you already have this keystone equipped or you have reached your maximum for keystones! \n"
														finalMessage += "```"
													    message.channel.sendMessage(finalMessage)		
													}
						    					}
						    					if(input[1] == "upgrade"){
						    						if(player.keystones[input[2]] < 5 && player.keystones[input[2]] != -1 && parseInt(input[3]) <= player.keystones.points_availible && parseInt(input[3]) > 0 && (player.keystones[input[2]] + parseInt(input[3])) <= 5){
						    							player.keystones[input[2]] += parseInt(input[3])
						    							player.keystones.points_availible -= parseInt(input[3])
						    							finalMessage = "```"
														finalMessage += player.name + " has added " + parseInt(input[3]) + " points to keystone " + input[2].replace(/_/g," ") + "! \n"
														finalMessage += "```"
														// player.bonus_health = (75 * player.keystones.hearty_warrior)
														updatePlayer(player,function(){
															message.channel.sendMessage(finalMessage)	
														})
						    						} else {
						    							finalMessage = "```"
														finalMessage += "You are unable to assign " + parseInt(input[3]) + " points to that keystone! \n"
														finalMessage += "```"
													    message.channel.sendMessage(finalMessage)	
						    						}
						    					}
						    					if(input[1] == "remove"){
						    						if (player.keystones[input[2]] > -1) {
						    							player.keystones.points_availible += player.keystones[input[2]]
						    							player.keystones[input[2]] = -1
						    							player.keystones.assigned -= 1
						    							// player.bonus_health = (75 * player.keystones.hearty_warrior)
						    							finalMessage = "```"
														finalMessage += player.name + " has removed the keystone " + input[2].replace(/_/g," ") + "! \n"
														finalMessage += "```"
														updatePlayer(player,function(){
															message.channel.sendMessage(finalMessage)	
														})
						    						} else {
						    							finalMessage = "```"
														finalMessage += "You do not have that keystone assigned! \n"
														finalMessage += "```"
													    message.channel.sendMessage(finalMessage)	
						    						}
						    					}
						    					if(input[1] == "list"){
						    						finalMessage = "```"
						    						for (name in player.keystones){
						    							if(player.keystones[name] > -1 && name != "assigned" && name != "points_availible"){
						    								finalMessage += name.capitalize().replace(/_/g," ") + ": " + player.keystones[name] + "\n"
						    							}
						    						}
						    						if(finalMessage ==  "```"){
						    							finalMessage += "You have no keystones assigned! \n"
						    						}
						    						finalMessage += "```"
						    						message.channel.sendMessage(finalMessage)	
						    					}
						    					if(input[1] == "options"){
						    						finalMessage = "```"
						    						finalMessage += "reckless fighter: Attacks deal more damage but have added recoil \n"
													finalMessage += "giant slayer: Attacks deal small percentage of health damage \n"
													finalMessage += "strategic solider: Chosing different attack types increases damage \n"
													// finalMessage += "hearty warrior: Increased base health and regen health per turn \n"
													finalMessage += "unwavering spirit: Increased damage resistance but attacks do less damage \n"
													finalMessage += "focused mind: Chance to ignore status effects \n"
													finalMessage += "desperate mercenary: Gain poriton of damage done as health \n"
													finalMessage += "wise duelist: Increased damage done on tied and failed turns \n"
													finalMessage += "enraged gladiator : Increased damage when at low health \n"
						    						finalMessage += "```"
						    						message.channel.sendMessage(finalMessage)	
						    					}
						    				} else {
											finalMessage = "```"
											finalMessage += "You cannot complete this action while in a duel or trade! \n"
											finalMessage += "```"
										    message.channel.sendMessage(finalMessage)		
										}
									})
								})
					    	} else {
					    		finalMessage = "** *!keystone ** \n"
								finalMessage += "```"
								finalMessage += "Function: Manage keystones \n"
								finalMessage += "Usage: *!keystone (action) \n"
								finalMessage += "Example_1: *!keystone add reckless_fighter\n"
								finalMessage += "Example_2: *!keystone upgrade reckless_fighter 1\n"
								finalMessage += "Example_3: *!keystone remove reckless_fighter\n"
								finalMessage += "Example_4: *!keystone list\n"
								finalMessage += "Example_5: *!keystone options\n"
								finalMessage += "```"
						    	message.channel.sendMessage(finalMessage)		
					    	}
					    }
					    if (input[0]  == "*!skillassign") {
					    	if(input.length == 3){
						    		findDuel(message,function(duel){
						    			findTrade(message,function(trade){
						    				if(duel == undefined && trade == undefined) {
						    					player.confirming = "skill"
						    					if(input[1] == "strength" || input[1] == "speed" || input[1] == "perception"){
						    						if(parseInt(input[2]) <= player.skillpoints.availiable){
							    						player.assigningSkill = input[1];
							    						player.assigningPoints = parseInt(input[2])
								    					if(player.skillpoints.availiable > 0){
								    						var finalMessage = "```"
															    	finalMessage += "Are you sure you would like to assign " + parseInt(input[2]) +  "  skillpoints to " + input[1] + "? \n \n"
															    	finalMessage += "Type *!yes to confirm or *!no to cancel \n"
															    	finalMessage += "```"
														   	updatePlayer(player,function(){
														   		message.channel.sendMessage(finalMessage)	
														    })
								    					} else {
								    						finalMessage = "```"
															finalMessage += "You have no skillpoints to assign! \n"
															finalMessage += "```"
														    message.channel.sendMessage(finalMessage)	
								    					}
								    				} else {
							    					finalMessage = "```"
													finalMessage += "You do not have that many availiable skillpoints! \n"
													finalMessage += "```"
												    message.channel.sendMessage(finalMessage)	
							    					}
							    				} else {
							    					finalMessage = "```"
													finalMessage += "You must enter a valid skill! \n"
													finalMessage += "```"
												    message.channel.sendMessage(finalMessage)	
							    				}
						    				} else {
											finalMessage = "```"
											finalMessage += "You cannot complete this action while in a duel or trade! \n"
											finalMessage += "```"
										    message.channel.sendMessage(finalMessage)		
										}
									})
								})
					    	} else {
					    		finalMessage = "** *!skillassign ** \n"
								finalMessage += "```"
								finalMessage += "Function: Assign a skill point \n"
								finalMessage += "Usage: *!skillassign (stat) (amount) \n"
								finalMessage += "Example: *!skillassign strength 1\n"
								finalMessage += "```"
						    	message.channel.sendMessage(finalMessage)		
					    	}
					    }
					    if (input[0]  == "*!no" && input.length == 1) {
					    	if(player.confirming != null){
						    	var finalMessage = "```"
								finalMessage += "Request canceled \n"
								finalMessage += "```"	
						    	player.selectedItemIndex = null
						    	player.selectedAmount = null
						    	player.confirming = null
						    	player.desiredPurchase = null
						    	updatePlayer(player,function(){
						    		message.channel.sendMessage(finalMessage) 
						    	})
						    }
					    }
					    if (input[0]  == "*!yes" && input.length == 1) {
					    		if(player.confirming == "newlife"){
					    			if(player.lives_purchased < 3){
										player.lives_purchased += 1
										var now = new Date()
										player.life_timer = now.getTime() + 1800
										player.gold -= 1200
						    			player.monster_cores -= 100
						    			player.lives += 1
						    			var finalMessage = "```"
								    	finalMessage += player.name + " has purchased an extra life!"
								    	finalMessage += "```"
								    	player.confirming = null
									   	updatePlayer(player,function(){
									   		message.channel.sendMessage(finalMessage)	
									    })
									} else {
										var now = new Date()
										if(now.getTime() > player.life_timer){
											player.lives_purchased = 1
											player.life_timer = now.getTime() + 1800
											player.gold -= 1200
							    			player.monster_cores -= 100
							    			player.lives += 1
							    			var finalMessage = "```"
									    	finalMessage += player.name + " has purchased an extra life!"
									    	finalMessage += "```"
									    	player.confirming = null
										   	updatePlayer(player,function(){
										   		message.channel.sendMessage(finalMessage)	
										    })
										} else {
											finalMessage = "```"	
					    					finalMessage += "You have run out of life purchases \n"
											finalMessage += "You must wait " + parseInt((player.life_timer - now.getTime())/60000) + " minutes before being allowed to buy more lives \n"
											finalMessage += "```"
										    message.channel.sendMessage(finalMessage)	
										}
									}
					    		}
					    		if(player.confirming == "skill"){
					    			player.skillpoints[player.assigningSkill] += player.assigningPoints
					    			player.skillpoints.availiable -= player.assigningPoints
					    			var finalMessage = "```"
							    	finalMessage += player.name + " has assigned " + player.assigningPoints +  " points to " + player.assigningSkill + "!"
							    	finalMessage += "```"
							    	player.confirming = null
							    	player.assigningPoints = null
							    	player.assigningSkill = null
								   	updatePlayer(player,function(){
								   		message.channel.sendMessage(finalMessage)	
								    })
					    		}
						    	if(player.confirming == "purchase"){
						    		if(player.inventory == undefined){
						    			player.inventory = []
						    		}
						    		player.gold -= player.desiredPurchase.cost * player.selectedAmount 
						    		if(player.gold < 0 ){
						    			player.gold = 0
						    		}
						    		var missing = true
									for (var i = player.inventory.length - 1; i >= 0; i--) {
										if(player.inventory[i].name == player.desiredPurchase.name && player.inventory[i].level == player.desiredPurchase.level && player.desiredPurchase.level != undefined){
											player.inventory[i].count += parseInt(player.desiredPurchase.count)
											missing = false
										}
										if(player.inventory[i].name == player.desiredPurchase.name && player.inventory[i].item_id == player.desiredPurchase.item_id && player.desiredPurchase.item_id != undefined){
											player.inventory[i].count += parseInt(player.desiredPurchase.count)
											missing = false
										}			
									}			
									if(missing){
										player.inventory.push(player.desiredPurchase)
									}
									var finalMessage = "```"
							    	finalMessage += player.name + " purchased " + player.desiredPurchase.count + " " + player.desiredPurchase.name + "! \n"
							    	finalMessage += "```"
							    	player.confirming = null
							    	player.desiredPurchase = null
							    	player.selectedAmount = null
							    	updatePlayer(player,function(){
							    		message.channel.sendMessage(finalMessage)
							    	})
						    	}
						    	if(player.confirming == "equip"){
						    		var missing = true
									for (var i = player.inventory.length - 1; i >= 0; i--) {
										if(player.inventory[i].name == player.weapon.name && player.inventory[i].level == player.weapon.level){
											player.inventory[i].count += player.weapon.count
											missing = false
										}		
									}			
									if(missing){
										player.inventory.push(player.weapon)
									}
									player.weapon = player.inventory[player.selectedItemIndex]
									if (player.inventory[player.selectedItemIndex].count == 1){
										player.inventory.splice(player.selectedItemIndex,1)
									} else {
										player.inventory[player.selectedItemIndex].count -= 1
									}
									var finalMessage = "```"
							    	finalMessage += player.name + " equipped " + player.weapon.name + " as their primary weapon! \n"
							    	finalMessage += "```"
							    	player.confirming = null
							    	player.selectedItemIndex = null
									updatePlayer(player,function(){
							    		message.channel.sendMessage(finalMessage)	
							    	})
						    	}
						    	if(player.confirming == "use"){
						    		if(player.inventory[player.selectedItemIndex].useEffect == "heal"){
						    			player.health += player.inventory[player.selectedItemIndex].modifier * player.selectedAmount
						    			if(player.health > player.max_health){
						    				player.health = player.max_health
						    			}
						    		}
						    		var finalMessage = "```"
							    	finalMessage += player.name + " used " + player.selectedAmount + " " + player.inventory[player.selectedItemIndex].name + "! \n"
							    	finalMessage += "```"
						    		if(player.inventory[player.selectedItemIndex].count == player.selectedAmount){
						    			player.inventory.splice(player.selectedItemIndex,1)	
						    		} else {
						    			player.inventory[player.selectedItemIndex].count -= player.selectedAmount	
						    		}
							    	player.confirming = null
							    	player.selectedItemIndex = null
							    	player.selectedAmount = null
									updatePlayer(player,function(){
							    		message.channel.sendMessage(finalMessage)	
							    	})
						    	}
						    	if(player.confirming == "sell"){
						    		var goldGained = 0;
						    		if(player.inventory[player.selectedItemIndex].cost != undefined){
						    			goldGained = parseInt(player.inventory[player.selectedItemIndex].cost * .7)
						    		}
						    		if(player.inventory[player.selectedItemIndex].sellValue != undefined){
						    			goldGained = player.inventory[player.selectedItemIndex].sellValue
						    		}
						    		if(goldGained == 0){
						    			goldGained = player.inventory[player.selectedItemIndex].goldToUpgrade * 0.5
						    		}
						    		goldGained *= player.selectedAmount
						    		player.gold += parseInt(goldGained)
						    		var finalMessage = "```"
							    	finalMessage += player.name + " sold " + player.inventory[player.selectedItemIndex].name + " for " + parseInt(goldGained) + " gold! \n"
							    	finalMessage += "```"
							    	if(player.gold < 0 ){
						    			player.gold = 0
						    		}
						    		if(player.inventory[player.selectedItemIndex].count == player.selectedAmount){
						    			player.inventory.splice(player.selectedItemIndex,1)	
						    		} else {
						    			player.inventory[player.selectedItemIndex].count -= player.selectedAmount	
						    		}
						    		player.selectedAmount = null
							    	player.confirming = null
							    	player.selectedItemIndex = null
									updatePlayer(player,function(){
							    		message.channel.sendMessage(finalMessage)	
							    	})
						    	}
						    	if(player.confirming == "upgrade"){
						    		if(!player.custom_equipped){
							    		player.gold -= parseInt(player.weapon.goldToUpgrade * player.weapon.level)
							    		player.weapon.level += 1
							    		var finalMessage = "```"
								    	finalMessage += player.name + " upgraded " + player.weapon.name + " to level " + player.weapon.level + "! \n"
								    	finalMessage += "```"
								    	player.confirming = null
								    } else {
								    	player.gold -= parseInt(player.custom_weapon.goldToUpgrade * player.custom_weapon.level)
							    		player.custom_weapon.level += 1
							    		var finalMessage = "```"
								    	finalMessage += player.name + " upgraded " + player.custom_weapon.name + " to level " + player.custom_weapon.level + "! \n"
								    	finalMessage += "```"
								    	player.confirming = null
								    }
						    		updatePlayer(player,function(){
							    		message.channel.sendMessage(finalMessage)	
							    	})
						    	}
						    	if(player.confirming == "comboUpgrade"){
						    		player.gold -= player.combos[player.comboIndex].level * 150
						    		player.combos[player.comboIndex].level += 1
						    		var finalMessage = "```"
							    	finalMessage += player.name + " upgraded " + player.combos[player.comboIndex].name + " to level " + player.combos[player.comboIndex].level + "! \n"
							    	finalMessage += "```"
							    	player.confirming = null
						    		updatePlayer(player,function(){
							    		message.channel.sendMessage(finalMessage)	
							    	})
						    	}
						    	if(player.confirming == "comboRemove"){
						    		var finalMessage = "```"
							    	finalMessage += player.name + " removed " + player.combos[player.comboIndex].name + "! \n"
							    	finalMessage += "```"
							    	player.confirming = null
							    	player.combos.splice(player.comboIndex,1)
						    		updatePlayer(player,function(){
							    		message.channel.sendMessage(finalMessage)	
							    	})
						    	}
						    	if(player.confirming == "skillreset"){
						    		var cost = 100 * (player.skillpoints.strength + player.skillpoints.speed + player.skillpoints.perception)
						    		player.skillpoints.availiable += (player.skillpoints.strength + player.skillpoints.speed + player.skillpoints.perception)
						    		player.skillpoints.strength = 0
						    		player.skillpoints.speed = 0
						    		player.skillpoints.perception = 0
						    		player.gold -= cost
						    		var finalMessage = "```"
							    	finalMessage += player.name + " cleared their skillpoints! \n"
							    	finalMessage += "```"
							    	player.confirming = null
						    		updatePlayer(player,function(){
							    		message.channel.sendMessage(finalMessage)	
							    	})
						    	}
					    }
					    if (input[0] == "*!remove" && input.length == 1 )  {
					    	findDuel(message,function(duel){
					    		findTrade(message,function(trade){
						    		if(duel == undefined && trade == undefined){
								    	removePlayer(player,function(player){
								    		var finalMessage = "```"
					    					finalMessage += "The Legend of " + player.name.capitalize() + " Has Come To An End.. \n"
					    					finalMessage += "```"
										    message.channel.sendMessage(finalMessage)
								    	})
								    } else {
								    	finalMessage = "```"
											finalMessage += "You cannot complete this action while in a duel or trade! \n"
											finalMessage += "```"
										    message.channel.sendMessage(finalMessage)		
								    }
								})
					    	})
						}

						if (input[0] == "*!cancel" && input.length == 1 )  {
							if (player.searching_for_duel){
								player.searching_for_duel = false
								updatePlayer(player,function(){
									message.channel.sendMessage("You have left the matchmaking queue!")	
								})
							} else {
								message.channel.sendMessage("You are not currently in matchmaking!")
							}
						}
						if (input[0] == "*!accept" && input.length == 1 )  {
					    	findDuel(message,function(duel){
					    		if(duel != undefined){
							    	if (duel.type == "player"){
							    		if(duel.player2.player.id == player.id && !duel.started){
							    			duel.start()
							    		}
							    	} else {
							    		message.channel.sendMessage("You can not accept CPU duels!")	
							    	}
							    } else {
							    	message.channel.sendMessage("You have not been challenged to a duel yet!")
							    }
					    	})
						}
						if (input[0] == "*!decline" && input.length == 1 )  {
					    	findDuel(message,function(duel){
					    		if(duel != undefined){
							    	if (duel.type == "player"){
							    		if(!duel.started){
							    			duel.end(player)
							    		}
							    	} else {
							    		message.channel.sendMessage("You can not decline CPU duels!")	
							    	}
							    } else {
							    	message.channel.sendMessage("You have not been challenged to a duel yet!")
							    }
					    	})
						}
						if (input[0] == "*!taccept" && input.length == 1 )  {
					    	findTrade(message,function(trade){
					    		if(trade != undefined){
							    	if(trade.player2.player.id == player.id && !trade.started){
							    		trade.start()
							    	}
							    } else {
							    	message.channel.sendMessage("You have not been invited to a trade yet!")
							    }
					    	})
						}
						if (input[0] == "*!tdecline" && input.length == 1 )  {
					    	findTrade(message,function(trade){
					    		if(trade != undefined){
							    	if(!trade.started){
							    		trade.end(player)
							    	}
							    } else {
							    	message.channel.sendMessage("You have not been invited to a trade yet!")
							    }
					    	})
						}
						if (input[0] == "*!forfeit" && input.length == 1 )  {
					    	findDuel(message,function(duel){
					    		if(duel != undefined){
							    	if (duel.type == "player" && duel.started){
							    		duel.forfeit(player)
							    	} else {
							    		message.channel.sendMessage("You can not forfeit CPU duels!")	
							    	}
							    } else {
							    	message.channel.sendMessage("You have not been challenged to a duel yet!")
							    }
					    	})
						}
						if (input[0] == "*!leave" && input.length == 1 )  {
					    	findTrade(message,function(trade){
					    		if(trade != undefined){
					    			deleteTrade(trade.id)
					    			var finalMessage = "```"
				    				finalMessage += "The trade has been canceled! \n"
				    				finalMessage += "```"
									message.channel.sendMessage(finalMessage)
					    		} else {
							    	message.channel.sendMessage("You are not in a trade!")
							    }
					    	})
						}
						if (input[0] == "*!create")  {
							var finalMessage = "```"
		    				finalMessage += "The Legend of " + player.name.capitalize() + " has already begun! \n"
		    				finalMessage += "```"
							message.channel.sendMessage(finalMessage)
						}
						if(input[0] == "*!silence" && input.length == 1){
							if(player.recieveAlerts){
								player.recieveAlerts = false
								var finalMessage = "```"
			    				finalMessage += "You will no longer recieve player alerts \n"
			    				finalMessage += "```"
								message.channel.sendMessage(finalMessage)
							} else {
								player.recieveAlerts = true
								var finalMessage = "```"
			    				finalMessage += "You will now recieve player alerts \n"
			    				finalMessage += "```"
								message.channel.sendMessage(finalMessage)
							}
							updatePlayer(player,function(){})
						}
				} else if(input[0] != "*!help"){
					var finalMessage = "```"
		    		finalMessage += "No profile found for " + message.author.username + ". Use *!create to create a profile. \n"
		    		finalMessage += "```"
					message.channel.sendMessage(finalMessage)
				}
				if(input[0] == "*!fremove" && input.length == 1){
					if(message.author.id == "163809334852190208"){
						var finalMessage = "```"
		    			finalMessage += "I have been force removed by my creator! \n"
		    			finalMessage += "```"
		    			message.channel.sendMessage(finalMessage)
						message.guild.leave()
					}
				}
				if(input[0] == "*!reset" && input.length == 1){
					if(message.author.id == "163809334852190208"){
						duels = []
						trades = []
						activeBossFighters = []
						var finalMessage = "```"
		    			finalMessage += "All duels and trades have been reset! \n"
		    			finalMessage += "```"
		    			var players_data = firebase.database().ref("players");
		    			players_data.once('value').then(function(snapshot) {
								for(id in snapshot.val()){
									if(snapshot.val()[id].recieveAlerts){
										client.fetchUser(String(id)).then(user => 
											user.createDM().then(dm => {
														dm.sendMessage(finalMessage)
													}
												)
											)
									}
								}
						});
					}
				}
				if(input[0] == "*!reset_trades" && input.length == 1){
					if(message.author.id == "163809334852190208"){
						trades = []
						var finalMessage = "```"
		    			finalMessage += "All trades have been reset! \n"
		    			finalMessage += "```"
		    			var players_data = firebase.database().ref("players");
		    			players_data.once('value').then(function(snapshot) {
								for(id in snapshot.val()){
									if(snapshot.val()[id].recieveAlerts){
										client.fetchUser(String(id)).then(user => 
											user.createDM().then(dm => {
														dm.sendMessage(finalMessage)
													}
												)
											)
									}
								}
						});
					}
				}
				if(input[0] == "*!reset_duels" && input.length == 1){
					if(message.author.id == "163809334852190208"){
						duels = []
						activeBossFighters = []
						var finalMessage = "```"
		    			finalMessage += "All duels have been reset! \n"
		    			finalMessage += "```"
		    			var players_data = firebase.database().ref("players");
		    			players_data.once('value').then(function(snapshot) {
								for(id in snapshot.val()){
									if(snapshot.val()[id].recieveAlerts){
										client.fetchUser(String(id)).then(user => 
											user.createDM().then(dm => {
														dm.sendMessage(finalMessage)
													}
												)
											)
									}
								}
						});
					}
				}
				if(input[0] == "*!duels" && input.length == 1){
					var finalMessage = "```"
					for (var i = duels.length - 1; i >= 0; i--) {
						finalMessage +=	duels[i].player1.player.name + "(" + duels[i].player1.player.id + ") vs "
						if (duels[i].player2.player.id != undefined){
							finalMessage +=	duels[i].player2.player.name + "(" + duels[i].player2.player.id + ") "
						} else {
							finalMessage +=	duels[i].player2.player.name + "\n"
						}
					};
		    		finalMessage += "```"
		    		if(finalMessage == "``````"){
		    			finalMessage = "```"
		    			finalMessage += "No duels are happening at this moment"
		    			finalMessage += "```"
		    		}
		    		message.channel.sendMessage(finalMessage)
				}
				if(input[0] == "*!trades" && input.length == 1){
					if(message.author.id == "163809334852190208"){
						var finalMessage = "```"
						for (var i = trades.length - 1; i >= 0; i--) {
						finalMessage +=	String(trades[i].player1.player.name,trades[i].player1.player.name.id) + " is trading with "
						finalMessage +=	String(trades[i].player2.player.name,trades[i].player2.player.name.id) + " "
						};
		    			finalMessage += "```"
		    			client.fetchUser(message.author.id).then(user => 
							user.createDM().then(dm => {
									dm.sendMessage(finalMessage)
								}
							)
						)
					}
				}
				// if(input[0] == "*!giveWeaponAll" && input.length == 2){
				// 	if(message.author.id == "163809334852190208"){
				// 		for (var i = data.weapons.length - 1; i >= 0; i--) {
				// 			if(data.weapons[i].name.toLowerCase() == input[1].replace(/_/g," ") || data.weapons[i].id == input[1]){
				// 				var player_data = firebase.database().ref("players/");
				// 				player_data.once('value').then(function(snapshot) {
				// 					var players = snapshot.val()
				// 						for(id in players){
				// 							var player = players[id]
				// 							givePlayer(player,data.weapons[i])
				// 						}
				// 				})
				// 			}
				// 		}
				// 	}
				// }
				if(input[0] == "*!startboss" && input.length == 1){
					if(message.author.id == "163809334852190208"){
						makeBoss()
					}
				}
				if(input[0] == "*!player_db" && input.length == 2){
					if(message.author.id == "163809334852190208"){
						var id = input[1].split("@")[1].replace(">","").replace("!","")
						var finalMessage = "https://console.firebase.google.com/project/discord-duels/database/data/players/" + id
		    			client.fetchUser(message.author.id).then(user => 
							user.createDM().then(dm => {
									dm.sendMessage(finalMessage)
								}
							)
						)
					}
				}
				if(input[0] == "*!player_db" && input.length >= 2){
					if(message.author.id == "163809334852190208"){
						if(input[1].substring(0,2) == "<@" && input[1].slice(-1) == ">"){
							getPlayer(input[1].split("@")[1].replace(">","").replace("!",""),function(player2){
								if(input[2] == "view"){
									var finalMessage = "```"
									for(thing in player2){
										finalMessage += thing + ": " + player2[thing] + " \n"
									}
									finalMessage += "```"
									client.fetchUser("163809334852190208").then(user => 
										user.createDM().then(dm => {
												dm.sendMessage(finalMessage)
											}
										)
									)
								}
								if(input[2] == "set"){
									if(player2[rawinput[3]] != undefined){
										var value = parseInt(rawinput[4])
										if(isNaN(value)){
											player2[rawinput[3]] = rawinput[4]
										} else {
											player2[rawinput[3]] = value
										}
									}
									updatePlayer(player2,function(){})
								}
							})
						} else {
							getPlayer(input[1],function(player2){
								if(input[2] == "view"){
									var finalMessage = "```"
									for(thing in player2){
										finalMessage += thing + ": " + player2[thing] + " \n"
									}
									finalMessage += "```"
									client.fetchUser("163809334852190208").then(user => 
										user.createDM().then(dm => {
												dm.sendMessage(finalMessage)
											}
										)
									)
								}
								if(input[2] == "set"){
									if(player2[rawinput[3]] != undefined){
										var value = parseInt(rawinput[4])
										if(isNaN(value)){
											player2[rawinput[3]] = rawinput[4]
										} else {
											player2[rawinput[3]] = value
										}
									}
									updatePlayer(player2,function(){})
								}
							})
						}
					}	
				}
				if(input[0] == "*!announce" && input.length > 2){
					if(message.author.id == "163809334852190208"){
						var finalMessage = message.content.split("!announce ")[1];
						var players_data = firebase.database().ref("players");
						players_data.once('value').then(function(snapshot) {
								for(id in snapshot.val()){
									if(snapshot.val()[id].recieveAlerts){
										client.fetchUser(String(id)).then(user => 
											user.createDM().then(dm => {
														dm.sendMessage(finalMessage)
													}
												)
											)
									}
								}
						});
					}
				}
				if(input[0] == "*!update"){
					if(message.author.id == "163809334852190208"){
						var players_data = firebase.database().ref("players");
						players_data.once('value').then(function(snapshot) {
								for(id in snapshot.val()){
									if(snapshot.val()[id].recieveAlerts){
										client.fetchUser(String(id)).then(user => 
											user.createDM().then(dm => {
														dm.sendMessage(changelog)
													}
												)
											)
									}
								}
						});
					}
				}
				if(input[0] == "*!clearai"){
					if(message.author.id == "163809334852190208"){
						var player_data = firebase.database().ref("ML/");
						player_data.once('value').then(function(snapshot) {
							snapshot.forEach(function(child) {
							        child.ref.remove();
						    });
						});
					}
				}
				if(input[0] == "*!question"){
					if(input.length >= 2){
						var finalMessage = player.name + "-(" + player.id + "): "
							var questionCase = message.content.split(player.prefix + "question ")[1];
							if(questionCase == undefined){
								questionCase = message.content.split("*!question ")[1];
							}
							finalMessage += questionCase
						var	messageReply = "```"
							messageReply += "Thank you for asking a question, The Discord Duels team will try to reply as soon as possible! \n"
							messageReply += "```"
							message.channel.sendMessage(messageReply)
							client.channels.get("307654117440880640").sendMessage(finalMessage)
						} else {
							finalMessage = "** *!question ** \n"
							finalMessage += "```"
							finalMessage += "Ask a question directly to Discord Duels staff\n"
							finalMessage += "Usage: *!question (message) \n"
							finalMessage += "Example: *!question Hi Darkspine77! \n"
							finalMessage += "```"
						    message.channel.sendMessage(finalMessage)
						}
				}
				if(input[0] == "*!report"){
					if(input.length >= 2){
						var finalMessage = player.name + "-(" + player.id + "): "
							var reportCase = message.content.split(player.prefix + "report ")[1];
							if(reportCase == undefined){
								reportCase =  message.content.split(player.prefix + "Report ")[1];
							}
							if(reportCase == undefined){
								reportCase = message.content.split("*!Report ")[1];
							}
							if(reportCase == undefined){
								reportCase = message.content.split("*!report ")[1];
							}
							finalMessage += reportCase
						var	messageReply = "```"
							messageReply += "Thank you for reporting a problem you found, The Discord Duels team apologizes for any inconvenience you have experienced! \n"
							messageReply += "```"
							message.channel.sendMessage(messageReply)
							client.channels.get("307654720925728768").sendMessage(finalMessage)
						} else {
							finalMessage = "** *!report ** \n"
							finalMessage += "```"
							finalMessage += "Report a bug directly to Discord Duels staff\n"
							finalMessage += "Usage: *!report (message) \n"
							finalMessage += "Example: *!report Hi Darkspine77! \n"
							finalMessage += "```"
						    message.channel.sendMessage(finalMessage)
						}
				}
				if(input[0] == "*!prefix"){
					findDuel(message,function(duel){
		    			findTrade(message,function(trade){
		    				if(duel == undefined && trade == undefined) {
								if (input.length == 2) {
									player.prefix = input[1].toLowerCase()
									var	messageReply = "```"
									messageReply += player.name + "'s prefix has been changed to " + player.prefix +"! \n"
									messageReply += "```"
									message.channel.sendMessage(messageReply)
									updatePlayer(player,function(){})
								} else {
									finalMessage = "** *!prefix ** \n"
									finalMessage += "```"
									finalMessage += "Change your command prefix\n"
									finalMessage += "Usage: *!prefix (new prefix) \n"
									finalMessage += "Example: *!prefix !* \n"
									finalMessage += "```"
								    message.channel.sendMessage(finalMessage)
								}	
							}
						})
					})
				}
				if(input[0] == "*!suggest"){
					if(input.length > 1){
						var finalMessage = player.name + "-(" + player.id + "): "
							var suggestion = message.content.split(player.prefix + "suggest ")[1];
							if(suggestion == undefined){
								suggestion = message.content.split("*!suggest ")[1];
							}
							finalMessage += suggestion
							client.channels.get("307654475592630272").sendMessage(finalMessage)
							finalMessage = "```"
							finalMessage += "Thank you for your suggestion! \n"
							finalMessage += "```"
							message.channel.sendMessage(finalMessage)
						} else {
							finalMessage = "** *!suggest ** \n"
							finalMessage += "```"
							finalMessage += "Send an idea for the game\n"
							finalMessage += "Usage: *!suggest (message) \n"
							finalMessage += "Example: *!suggest Add more furries \n"
							finalMessage += "```"
						    message.channel.sendMessage(finalMessage)
						}
				}
				if(input[0] == "*!msg"){
					if(message.author.id == "163809334852190208"){
						if(input.length > 2){
							if(String(parseInt(input[1])).length != 3){
								var finalMessage = message.content.split("| ")[1];
								client.fetchUser(input[1]).then(user => 
									user.createDM().then(dm => {
											dm.sendMessage(finalMessage)
										}
									)
								)
							} else {
								var searchName = input[1].replace(/_/g," ").toLowerCase();
						    	var player_data = firebase.database().ref("players/");
								player_data.once('value').then(function(snapshot) {
									var players = []
									for (id in snapshot.val()) {
										if(searchName == snapshot.val()[id].name.toLowerCase()){
								    		var finalMessage = message.content.split("| ")[1];
								    		client.fetchUser(id).then(user => 
												user.createDM().then(dm => {
														dm.sendMessage(finalMessage)
													}
												)
											)
										}
									};
								})
							} 
						}
					}
				}
				if(input[0] == "*!info"){
					finalMessage = ""
					if(input.length == 2){
						if (input[1] == "duels") {
							finalMessage += "**Duels**"
							finalMessage += "```"
							finalMessage += "Duels are turn based battles that players can participate in from the direct message created by Discord Duels \n"
							finalMessage += "While in duels players and NPCs will use 3 different attacks: Strike | Counter | Rush\n"
							finalMessage += "Each participant in a duel has a weapon and the amount of damage they deal in one turn is affected by what attack they choose and whether they win the turn, lose the turn, or it is a tied turn \n"
							finalMessage += "The winner is determined similar to rocks-paper-scissors: Rush -> Strike -> Counter -> Rush \n"
							finalMessage += "If it is a tied turn both players will do 50% of their weapons damage for that attack type\n"
							finalMessage += "If a player wins a turn they do 100% of their weapons damage for that attack type\n"
							finalMessage += "If a player loses a turn they do 25% of their weapons damage for that attack type\n"
							finalMessage += "```"
						}
						if (input[1] == "regen") {
							finalMessage += "**Health Regen**"
							finalMessage += "```"
							finalMessage += "Currently, upon dying from a NPC battle, you will lose a life\n"
							finalMessage += "If you die while at 0 lives, your account is deleted \n"
							finalMessage += "To prevent this there are three ways of recovering health \n"
							finalMessage += "First, you can use the *!heal command to regen some health instantly for the price of some gold, the higher level you are and the more health you have, the more gold you spend \n"
							finalMessage += "Second, some weapons have effects that regenerate your health \n"
							finalMessage += "Third, upon leveling up you gain 10% of your new maximum health \n"
							finalMessage += "```"
						}
						if (input[1] == "combos") {
							finalMessage += "**Combos**"
							finalMessage += "```"
							finalMessage += "Combos are special ways you can activate additional effects to benefit yourself in a battle\n"
							finalMessage += "There are 4 different types of combos: damage / heal / evade / resist\n"
							finalMessage += "With the *!combos command you can create a combo with a custom recipie (strike-strike-strike) and then choose an effect\n"
							finalMessage += "Once you have creaed a combo you can upgrade it up to 4 times to increase its effctiveness\n"
							finalMessage += "To active a combo you must preform your 3 step attack recipe in order\n"
							finalMessage += "```"
						}
						if (input[1] == "skillpoints") {
							finalMessage += "**Skillpoints**"
							finalMessage += "```"
							finalMessage += "Skillpoints are a resource you can gain from leveling up \n"
							finalMessage += "Skills can be assigned to 3 different stats using the *!skillassign command\n"
							finalMessage += "Those stats are: speed / strength / perception\n"
							finalMessage += "The stats are connected to the different attacks: rush / strike / counter\n"
							finalMessage += "For every skill point added to a stat you will deal additional damage with it respective attack\n"
							finalMessage += "You will also take less damage from the attack that is less effective to the respective attack type \n"
							finalMessage += "However you will take more damage from the attack that is more effetive against the respective attack type\n"
							finalMessage += "```"
						}
						if (input[1] == "effects") {
							finalMessage += "**Status Effects**"
							finalMessage += "```"
							finalMessage += "There are currently 4 different status effects\n"
							finalMessage += "Stun: Player deals no damage and turn is counted as a loss for them\n"
							finalMessage += "Stagger: Player deals 75% less damage\n"
							finalMessage += "Bleed: Player takes percentage of health damage\n"
							finalMessage += "Dizzy: Player takes damage based on damage done\n"
							finalMessage += "When a player has a status effect on them, they can not recieve another till the duration of the first status effect has ended\n"
							finalMessage += "```"
						}
						if (input[1] == "bosses") {
							finalMessage += "**Bosses**"
							finalMessage += "```"
							finalMessage += "Boss fights are Co-op PVE fight where players can face off against a difficult enemy to recieve gold, monster cores, and chaos fragments\n"
							finalMessage += "In order to recieve rewards players must hit a boss at least 10 times to recieve their reward \n"
							finalMessage += "```"
						}
					} else {
						finalMessage += "** *!info ** \n"
						finalMessage += "```"
						finalMessage += "Get game info on a topic\n"
						finalMessage += "Usage: *!info (topic) \n"
						finalMessage += "Example: *!info combos \n"
						finalMessage += "Topics: combos / regen / skillpoints / duels / effects / bosses / \n"
						finalMessage += "```"
					}
					message.channel.sendMessage(finalMessage)
				}				
				if(input[0] == "*!leaderboards"){
					if(input.length == 2) {
						var player_data = firebase.database().ref("players/");
						player_data.once('value').then(function(snapshot) {
							var players = []
							for (id in snapshot.val()) {
								players.push(snapshot.val()[id])
							}
							if(input[1] == "gold"){
								players.sort(function(a, b) {
								    return parseFloat(a.gold) - parseFloat(b.gold);
								});
								finalMessage = "** Gold Leaderboard ** \n"
								finalMessage += "```"
								for (var i = players.length - 1; i >= players.length - 21; i--) {
									finalMessage += players[i].name + ": " + players[i].gold + " \n"
								};
								finalMessage += "```"
								message.channel.sendMessage(finalMessage)
							}
							if(input[1] == "level"){
								players.sort(function(a, b) {
								    return parseFloat(a.level) - parseFloat(b.level);
								});
								finalMessage = "** Level Leaderboard ** \n"
								finalMessage += "```"
								for (var i = players.length - 1; i >= players.length - 21; i--) {
									finalMessage += players[i].name + ": " + players[i].level + " \n"
								};
								finalMessage += "```"
								message.channel.sendMessage(finalMessage)
							}
							if(input[1] == "elo"){
								players.sort(function(a, b) {
								    return parseFloat(a.elo) - parseFloat(b.elo);
								});
								finalMessage = "** Elo Leaderboard ** \n"
								finalMessage += "```"
								for (var i = players.length - 1; i >= players.length - 21; i--) {
									finalMessage += players[i].name + ": " + players[i].elo + " \n"
								};
								finalMessage += "```"
								message.channel.sendMessage(finalMessage)
							}
							if(input[1] == "monsters"){
								players.sort(function(a, b) {
								    return parseFloat(a.monsters_slain) - parseFloat(b.monsters_slain);
								});
								finalMessage = "** Monsters Slain Leaderboard ** \n"
								finalMessage += "```"
								for (var i = players.length - 1; i >= players.length - 21; i--) {
									finalMessage += players[i].name + ": " + players[i].monsters_slain + " \n"
								};
								finalMessage += "```"
								message.channel.sendMessage(finalMessage)
							}
							if(input[1] == "weapons"){
								finalMessage = "** Weapons Used Leaderboard ** \n"
								finalMessage += "```"
								var weaponArray = []
								for (var i = data.weapons.length - 1; i >= 0; i--) {
									var obj = {
										name:data.weapons[i].name,
										count:0
									}
									weaponArray.push(obj)
								};
								for (var x = players.length - 1; x >= 0; x--) {
									for (var y = weaponArray.length - 1; y >= 0; y--) {
										if(players[x].weapon.name == weaponArray[y].name){
											weaponArray[y].count += 1
										}
									};
								}
								weaponArray.sort(function(a, b) {
								    return parseFloat(a.count) - parseFloat(b.count);
								});
								for (var i = weaponArray.length - 1; i >= weaponArray.length - 21; i--) {
									if(weaponArray[i].name.toLowerCase() != "training stick"){
										finalMessage += weaponArray[i].name + ": " + weaponArray[i].count + " \n"
									}
								};
								finalMessage += "```"
								message.channel.sendMessage(finalMessage)
							}
						})
					} else {
						finalMessage = "** *!leaderboards ** \n"
						finalMessage += "```"
						finalMessage += "Function: View top 20 in a category\n"
						finalMessage += "Usage: *!leaderboard category \n"
						finalMessage += "Example: *!leaderboard gold \n"
						finalMessage += "Categories: gold / elo / level / monsters / weapons \n"
						finalMessage += "```"
						message.channel.sendMessage(finalMessage)
					}
				}

				if(input[0] == "*!version"){
					finalMessage = "```"
					finalMessage += "Discord Duels is currently running version " + version + " \n"
					finalMessage += "``` \n \n"
					finalMessage += changelog
					message.channel.sendMessage(finalMessage)
				}
				if(input[0] == "*!servers"){
					finalMessage = "```"
					finalMessage += "Discord Duels is currently on " + (client.guilds.array().length - 1) + " different servers! \n"
					finalMessage += "```"
					message.channel.sendMessage(finalMessage)
				}
				if(input[0] == "*!server"){
					finalMessage = "Join the Official Discord Duels Server!: https://discord.gg/ExSVxBy"
					client.fetchUser(String(message.author.id)).then(user => 
						user.createDM().then(dm => {
									dm.sendMessage(finalMessage)
								}
							)
						)
				}
				if(input[0] == "*!reddit"){
					finalMessage = "Join the Official Discord Duels Reddit!: https://www.reddit.com/r/DiscordDuels/"
					client.fetchUser(String(message.author.id)).then(user => 
						user.createDM().then(dm => {
									dm.sendMessage(finalMessage)
								}
							)
						)
				}
				if(input[0] == "*!addbot"){
					finalMessage = "Add Discord Duels to your server!: https://discordapp.com/oauth2/authorize?client_id=292789588399751168&scope=bot&permissions=3072"
					client.fetchUser(String(message.author.id)).then(user => 
						user.createDM().then(dm => {
									dm.sendMessage(finalMessage)
								}
							)
						)
				}
				if(input[0] == "*!players"){
					var player_data = firebase.database().ref("players/");
					player_data.once('value').then(function(snapshot) {
						var players = []
						for (id in snapshot.val()) {
							players.push(id)
						};
						finalMessage = "```"
						finalMessage += "Discord Duels currently has " + players.length + " different players! \n"
						finalMessage += "```"
						message.channel.sendMessage(finalMessage)
					})
				}
				if(input[0] == "*!creature"){
					if(input.length == 3 ){
						for (var i = data.creatures.length - 1; i >= 0; i--) {
							if(data.creatures[i].name.toLowerCase() == input[1].replace(/_/g," ")){
								if(parseInt(input[2]) < 31 && parseInt(input[2]) > -1){
									message.channel.sendMessage(printMob(parseInt(input[2]),data.creatures[i]))
								} else {
									finalMessage = "```"
									finalMessage += "Level range is only 0 - 30! \n"
									finalMessage += "```"
									message.channel.sendMessage(finalMessage)
								}
							}
						}
					} else {
						finalMessage = "** *!creature ** \n"
						finalMessage += "```"
						finalMessage += "Function: Get information on a creature\n"
						finalMessage += "Usage_1: *!creature (creature_name) (level) \n"
						finalMessage += "Usage_2: *!creature \n"
						finalMessage += "Entering 0 for level will display creature base stats \n"
						finalMessage += "Example_1: *!creature 001 1 \n"
						finalMessage += "Example_2: *!creature goblin 1 \n"
						finalMessage += "Example_3: *!creature \n"
						finalMessage += "```"
						message.channel.sendMessage(finalMessage)
					}
				}
				if(input[0] == "*!weapon"){
					if(input.length == 3 ){
						for (var i = data.weapons.length - 1; i >= 0; i--) {
							if(data.weapons[i].name.toLowerCase() == input[1].replace(/_/g," ") || data.weapons[i].id == input[1]){
								if(parseInt(input[2]) < 31 && parseInt(input[2]) > -1){
									message.channel.sendMessage(printWeapon(parseInt(input[2]),data.weapons[i]))
								} else {
									finalMessage = "```"
									finalMessage += "Level range is only 0 - 30! \n"
									finalMessage += "```"
									message.channel.sendMessage(finalMessage)
								}
							}
						}
					} else if(input.length == 1){
						if(player.custom_equipped){
							message.channel.sendMessage(printWeapon(player.custom_weapon.level,player.custom_weapon))
						} else {
							for (var i = data.weapons.length - 1; i >= 0; i--) {
								if(data.weapons[i].name.toLowerCase() == player.weapon.name.toLowerCase()){
									message.channel.sendMessage(printWeapon(player.weapon.level,data.weapons[i]))
								}
							}
						}
					} else {
						finalMessage = "** *!weapon ** \n"
						finalMessage += "```"
						finalMessage += "Function: Get information on a weapon\n"
						finalMessage += "Usage_1: *!weapon (weapon_name / weapon id) (level) \n"
						finalMessage += "Usage_2: *!weapon \n"
						finalMessage += "Entering 0 for level will display weapon base stats \n"
						finalMessage += "Example_1: *!weapon 001 1 \n"
						finalMessage += "Example_2: *!weapon beginner's_blade 1 \n"
						finalMessage += "Example_3: *!weapon \n"
						finalMessage += "```"
						message.channel.sendMessage(finalMessage)
					}
				}
				if(input[0] == "*!effect"){
					if(input.length == 3){
						for (var i = data.effects.length - 1; i >= 0; i--) {
							if(data.effects[i].name.toLowerCase() == input[1].replace(/_/g," ") || data.effects[i].id == input[1]){
								if(parseInt(input[2]) < 31 && parseInt(input[2]) > -1){
								message.channel.sendMessage(printEffect(parseInt(input[2]),data.effects[i]))
								} else {
									finalMessage = "```"
									finalMessage += "Level range is only 0 - 30! \n"
									finalMessage += "```"
									message.channel.sendMessage(finalMessage)
								}
							}
						}
					} else {
						finalMessage = "** *!effect ** \n"
						finalMessage += "```"
						finalMessage += "Function: Get information on a effect\n"
						finalMessage += "Usage: *!effect (effect_name / effect id) (level) \n"
						finalMessage += "Entering 0 for level will display effect base stats \n"
						finalMessage += "Example_1: *!effect 001 1 \n"
						finalMessage += "Example_2: *!effect resting_assualt 1\n"
						finalMessage += "```"
						message.channel.sendMessage(finalMessage)
					}
				}
			}
		})
	}
});

process.on("unhandledRejection", err => {
	console.error("Uncaught Promise Error: \n" + err.stack);
});	

    "id": "001",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Each time this character uses counter it gains a stack. This character's next strike attack will consume the stacks and inflict MODIFIER additional damage for each stack.",
    "effectOnMoves": [
      "1"
    ],
    "effectModifier": "damage",
    "modifier": [
      1,
      26
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": true,
    "equalCounter": "2",
    "clearCounters": true,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "none",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 0
  },
  {
    "name": "Defender's Resillience",
    "id": "002",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Counters heal for MODIFIER health",
    "effectOnMoves": [
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      3,
      60
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "none",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 0
  },
  {
    "name": "Furious Recovery",
    "id": "003",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Successful counters deal MODIFIER additional damage",
    "effectOnMoves": [
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      3,
      98
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "none",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 0
  },
  {
    "name": "Blood Sucker",
    "id": "004",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Strikes heal for MODIFIER health",
    "effectOnMoves": [
      "1"
    ],
    "effectModifier": "heal",
    "modifier": [
      1,
      29
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "none",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 0
  },
  {
    "name": "Fizzle",
    "id": "005",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Failed rounds heal for MODIFIER health",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      3,
      45
    ],
    "requiresSuccess": -1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "none",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 0
  },
  {
    "name": "Flamebreath Retreat",
    "id": "006",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Tied counters deal MODIFIER additional damage and cause bleed effect for STRENGTH% of target's health for 2 turns",
    "effectOnMoves": [
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      7,
      98
    ],
    "requiresSuccess": 2,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "none",
    "statusStrength": [
      0.01,
      0.033
    ],
    "statusDuration": 0
  },
  {
    "name": "Vengeful Arrow",
    "id": "007",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": true,
    "effectDescription": "Failed counters and rushes overpower and deal MODIFIER additional damage",
    "effectOnMoves": [
      "0",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      5,
      75
    ],
    "requiresSuccess": -1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "none",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 0
  },
  {
    "name": "Negation Aura",
    "id": "008",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Tied rounds heal for MODIFIER health",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      2,
      53
    ],
    "requiresSuccess": 2,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "none",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 0
  },
  {
    "name": "Violent Momentum",
    "id": "009",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Each time this character uses strike it gains a stack. This character's next strike attack will inflict MODIFIER additional damage for each stack.",
    "effectOnMoves": [
      "1"
    ],
    "effectModifier": "damage",
    "modifier": [
      2,
      26
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": true,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "none",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 0
  },
  {
    "name": "Light Barrier",
    "id": "010",
    "chance": 60,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks have a 40% chance to heal for MODIFIER health",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      8,
      90
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "none",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 0
  },
  {
    "name": "Constricting Grapple",
    "id": "011",
    "chance": 50,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Successful attacks have a 50% chance to stun for 1 turn",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": -1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 1
  },
  {
    "name": "Furious Gust",
    "id": "012",
    "chance": 60,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Strikes have 60% chance to stagger for 2 turns",
    "effectOnMoves": [
      "1"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stagger",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 2
  },
  {
    "name": "Radiance",
    "id": "013",
    "chance": 15,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks have a 15% chance to stun for 1 turn",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 1
  },
  {
    "name": "Night Edge",
    "id": "014",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Successful Strikes cause bleed effect for STRENGTH% of target health for 4 turns",
    "effectOnMoves": [
      "1"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.02,
      0.05500000000000001
    ],
    "statusDuration": 4
  },
  {
    "name": "Fatal Flurry",
    "id": "015",
    "chance": 35,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Rushes have a 35% chance to cause bleed effect for STRENGTH% of target health for 3 turns",
    "effectOnMoves": [
      "0"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.02,
      0.05500000000000001
    ],
    "statusDuration": 3
  },
  {
    "name": "Modular Strike",
    "id": "016",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": true,
    "effectDescription": "Failed strikes overpower and deal MODIFIER additional damage",
    "effectOnMoves": [
      "1"
    ],
    "effectModifier": "damage",
    "modifier": [
      8,
      45
    ],
    "requiresSuccess": -1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 4
  },
  {
    "name": "Forceful Shot",
    "id": "017",
    "chance": 40,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All Successful attacks have a 40% chance to cause stagger effect for three turns",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stagger",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 2
  },
  {
    "name": "Surge",
    "id": "018",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Failed Counters cause a stun effect for 2 turns",
    "effectOnMoves": [
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": -1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 2
  },
  {
    "name": "Breaker Slash",
    "id": "019",
    "chance": 10,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks have a 10% chance to cause bleed effect for STRENGTH% of target health for 10 turns",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      0,
      0,
      0
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.025,
      0.05500000000000001
    ],
    "statusDuration": 4
  },
  {
    "name": "Final Strike",
    "id": "020",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Sucessful Strikes after at least 1 Counter and 1 Rush cause bleed effect for STRENGTH% of target health for 2 turns",
    "effectOnMoves": [
      "1"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 1,
    "requiresCounters": true,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": true,
    "requiredCounters": [
      1,
      -1,
      1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.05,
      0.33
    ],
    "statusDuration": 2
  },
  {
    "name": "Sharpened Shuriken",
    "id": "021",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Sucessful Rushes cause bleed effect for STRENGTH% of target health for 3 turns",
    "effectOnMoves": [
      "0"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.04,
      0.132
    ],
    "statusDuration": 3
  },
  {
    "name": "Stunning Shuriken",
    "id": "022",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Tied Counters cause stun effect for 1 turn",
    "effectOnMoves": [
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 2,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 1
  },
  {
    "name": "Prepared Attack",
    "id": "023",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Sucessful Strikes deal MODIFIER additional damage",
    "effectOnMoves": [
      "1"
    ],
    "effectModifier": "damage",
    "modifier": [
      15,
      225
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      1
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 1
  },
  {
    "name": "Spider's Assualt",
    "id": "024",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Tied counters cause stun effect for 2 turns",
    "effectOnMoves": [
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 2,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 2
  },
  {
    "name": "Shield Block",
    "id": "025",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Successful Counters heal for MODIFIER health and cause stagger effect for 1 turn",
    "effectOnMoves": [
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      2,
      41
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stagger",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 1
  },
  {
    "name": "Twilight Resurgence",
    "id": "026",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Failed Strikes and Counters heal for MODIFIER health and cause dizzy effect for STRENGTH% for 3 turns",
    "effectOnMoves": [
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      10,
      45
    ],
    "requiresSuccess": -1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "dizzy",
    "statusStrength": [
      0.25,
      0.475
    ],
    "statusDuration": 1
  },
  {
    "name": "Moonlight Resonance",
    "id": "027",
    "chance": 10,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks have a 10% chance to cause stagger effect for 1 turn",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stagger",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 1
  },
  {
    "name": "Sharpened Fangs",
    "id": "028",
    "chance": 45,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Tied Attacks have a 45% chance to cause bleed effect for STRENGTH% of target health for 2 turns",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 2,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.03,
      0.099
    ],
    "statusDuration": 1
  },
  {
    "name": "Devour",
    "id": "029",
    "chance": 70,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Successful Attacks have a 70% chance to heal for MODIFIER health and cause bleed effect for STRENGTH% of target health for 1 turn",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      10,
      98
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.01,
      0.11000000000000001
    ],
    "statusDuration": 1
  },
  {
    "name": "Eternal Embers",
    "id": "030",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All Attacks cause bleed effect for STRENGTH% of target health for 1 turn",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.01,
      0.044000000000000004
    ],
    "statusDuration": 1
  },
  {
    "name": "Decent of Dawn",
    "id": "031",
    "chance": 0,
    "recoil": [
      1,
      52
    ],
    "overpower": false,
    "effectDescription": "Each time this character uses rush it gains a stack. This character's next Successful attack, after at least 1 rush, will consume the stacks and inflict MODIFIER additional damage for each stack.",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      5,
      150
    ],
    "requiresSuccess": 1,
    "requiresCounters": true,
    "modiferValueEqualsCounters": true,
    "equalCounter": "0",
    "clearCounters": true,
    "requiredCounters": [
      1,
      -1,
      -1
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.01,
      0.033
    ],
    "statusDuration": 1
  },
  {
    "name": "New Dawn",
    "id": "032",
    "chance": 70,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Failed attacks have a 70% chance to heal for MODIFIER health",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      5,
      75
    ],
    "requiresSuccess": -1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      -1
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.01,
      0.033
    ],
    "statusDuration": 1
  },
  {
    "name": "Reap Life",
    "id": "033",
    "chance": 50,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Tied attacks have a 50% chance to heal for MODIFIER health",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      40,
      225
    ],
    "requiresSuccess": 2,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      -1
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.01,
      0.033
    ],
    "statusDuration": 1
  },
  {
    "name": "Battering Blows",
    "id": "034",
    "chance": 70,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Each time this character uses rush it gains a stack. This character's next attack, after at least 1 rush, will inflict MODIFIER additional damage for each stack.",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      5,
      45
    ],
    "requiresSuccess": 0,
    "requiresCounters": true,
    "modiferValueEqualsCounters": true,
    "equalCounter": "0",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      -1
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.01,
      0.033
    ],
    "statusDuration": 1
  },
  {
    "name": "Cursed Shot",
    "id": "035",
    "chance": 75,
    "recoil": [
      10,
      286
    ],
    "overpower": false,
    "effectDescription": "All attacks have a 75% chance to do RECOIL recoil damage",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      -1
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.01,
      0.033
    ],
    "statusDuration": 2
  },
  {
    "name": "Banish",
    "id": "036",
    "chance": 0,
    "recoil": [
      8,
      78
    ],
    "overpower": false,
    "effectDescription": "Failed strikes cause stun effect for 3 turns and deal RECOIL recoil damage",
    "effectOnMoves": [
      "1"
    ],
    "effectModifier": "heal",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": -1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      -1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
        0,
        0
    ],
    "statusDuration": 3
  },
  {
    "name": "Malfunction",
    "id": "037",
    "chance": 40,
    "recoil": [
      8,
      130
    ],
    "overpower": false,
    "effectDescription": "All attcks have a 40% to deal RECOIL recoil damage and cause a stagger effect for 2 turns",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      -1,
      -1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stagger",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 2
  },
  {
    "name": "Last Kiss",
    "id": "038",
    "chance": 0,
    "recoil": [
      10,
      91
    ],
    "overpower": false,
    "effectDescription": "All attacks after 3 Counters cause a bleed effect for STRENGTH% of target's health effect for 4 turns and deal RECOIL recoil damage",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": true,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      -1,
      3
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.025,
      0.0825
    ],
    "statusDuration": 2
  },
  {
    "name": "Alure",
    "id": "039",
    "chance": 45,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All Counters have a 45% chance to cause a stun effect 2 turns. Also, for every counter, Counters do MODIFIER less damage",
    "effectOnMoves": [
      "2"
    ],
    "effectModifier": "lessdamage",
    "modifier": [
      1,
      15
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": true,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      -1,
      4
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 2
  },
  {
    "name": "End Life",
    "id": "040",
    "chance": 9,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks have a 9% chance to cause a bleed effect for STRENGTH% of target's health for 1 turn",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      -1,
      4
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.25,
      0.8250000000000001
    ],
    "statusDuration": 1
  },
  {
    "name": "Element of Surprise",
    "id": "041",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "If the first attack is Successful, Deal MODIFIER additional damage",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      50,
      300
    ],
    "requiresSuccess": 1,
    "requiresCounters": true,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": 1,
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.25,
      0.8250000000000001
    ],
    "statusDuration": 2
  },
  {
    "name": "Sharp Wind",
    "id": "042",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Strikes cause a bleed effect for STRENGTH% of target's health for 2 turns",
    "effectOnMoves": [
      "1"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      -2,
      -2,
      -2
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.04,
      0.066
    ],
    "statusDuration": 2
  },
  {
    "name": "Premeditated End",
    "id": "043",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Counters after 1 Rush and 1 Strike deal MODIFIER additional damage",
    "effectOnMoves": [
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      80,
      450
    ],
    "requiresSuccess": 0,
    "requiresCounters": true,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": true,
    "requiredCounters": [
      1,
      1,
      -1
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.07,
      0.099
    ],
    "statusDuration": 2
  },
  {
    "name": "Wrecker Blade",
    "id": "044",
    "chance": 65,
    "recoil": [
      0,
      0
    ],
    "overpower": true,
    "effectDescription": "All attacks have a 85% chance to overpower",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      1,
      -1
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "stagger",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 4
  },
  {
    "name": "Heated Blade",
    "id": "045",
    "chance": 80,
    "recoil": [
      2,
      26
    ],
    "overpower": true,
    "effectDescription": "All attacks have a 80% chance to deal RECOIL recoil damage and cause a bleed effect for STRENGTH% of target's health for 1 turn ",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      1,
      -1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.02,
      0.044000000000000004
    ],
    "statusDuration": 2
  },
  {
    "name": "Strike of Zeus",
    "id": "046",
    "chance": 0,
    "recoil": [
      10,
      65
    ],
    "overpower": true,
    "effectDescription": "Successful Strikes overpower and deal MODIFIER additonal damage and RECOIL recoil damage",
    "effectOnMoves": [
      "1"
    ],
    "effectModifier": "damage",
    "modifier": [
      30,
      225
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      1,
      -1
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.02,
      0.044000000000000004
    ],
    "statusDuration": 2
  },
  {
    "name": "Swallow",
    "id": "047",
    "chance": 40,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Failed attacks have a 40% chance to stun for 6 turns",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": -1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      1,
      -1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 6
  },
  {
    "name": "Oceanic Pressure",
    "id": "048",
    "chance": 0,
    "recoil": [
      24,
      182
    ],
    "overpower": false,
    "effectDescription": "Successful attacks deal MODIFIER additional damage and RECOIL recoil damage",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      12,
      105
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      1,
      1,
      -1
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 5
  },
  {
    "name": "Submerge",
    "id": "049",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "After at least 1 Counters, 1 Strikes, and 1 Rushes all attacks consume stacks, heal for MODIFIER health and cause a stun effect on the user for 4 turns",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      18,
      150
    ],
    "requiresSuccess": 0,
    "requiresCounters": true,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": true,
    "requiredCounters": [
      2,
      2,
      2
    ],
    "applyStatus": true,
    "statusTarget": "self",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 4
  },
  {
    "name": "Gambit Throw",
    "id": "050",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "After 1 Strike, all attacks do MODIFIER less damage",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "lessdamage",
    "modifier": [
      50,
      450
    ],
    "requiresSuccess": 0,
    "requiresCounters": true,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      2,
      -1
    ],
    "applyStatus": false,
    "statusTarget": "self",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 4
  },
  {
    "name": "Lucky Card",
    "id": "051",
    "chance": 50,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks have a 50% to deal MODIFIER additional damage",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      20,
      100
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      2,
      -1
    ],
    "applyStatus": false,
    "statusTarget": "self",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 4
  },
  {
    "name": "Unlucky Card",
    "id": "052",
    "chance": 50,
    "recoil": [
      20,
      100
    ],
    "overpower": false,
    "effectDescription": "All attacks have a 50% to deal RECOIL recoil damage",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      2,
      -1
    ],
    "applyStatus": false,
    "statusTarget": "self",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 4
  },
  {
    "name": "Corrode",
    "id": "053",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks cause a bleed effect for STRENGTH% of target health for 3 turns",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      2,
      -1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.02,
      0.04
    ],
    "statusDuration": 3
  },
  {
    "name": "Acidic Belch",
    "id": "054",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Successful attacks deal MODIFIER additional damage",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      30,
      70
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      2,
      -1
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.02,
      0.04
    ],
    "statusDuration": 3
  },
  {
    "name": "Eveloping Sunshine",
    "id": "055",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks cause dizzy effect for STRENGTH% for 1 turn",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      2,
      -1
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "dizzy",
    "statusStrength": [
      0.20,
      0.40
    ],
    "statusDuration": 1
  },
  {
    "name": "From Beneath",
    "id": "056",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks after at least 2 Rushes, 2 Strikes, and 2 Counteres, clear stacks, deal MODIFIER additional damage and cause stun effect for 2 turns",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      25,
      75
    ],
    "requiresSuccess": 0,
    "requiresCounters": true,
    "modiferValueEqualsCounters": false,
    "equalCounter": "1",
    "clearCounters": true,
    "requiredCounters": [
      2,
      2,
      2
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 2
  },
  {
    "name": "Power Engine",
    "id": "057",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "For every Counter, all Rushes and Strikes deal MODIFIER additional damage",
    "effectOnMoves": [
      "0",
      "1"
    ],
    "effectModifier": "damage",
    "modifier": [
      7,
      35
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": true,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      1,
      1,
      1
    ],
    "applyStatus": false,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 2
  },
  {
    "name": "Over Heat",
    "id": "058",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "After 8 Counters, all attcks clear stacks and cause a bleed effect on the user for STRENGTH% of user health for 4 turns",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": true,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": true,
    "requiredCounters": [
      -1,
      -1,
      8
    ],
    "applyStatus": true,
    "statusTarget": "self",
    "statusEffect": "bleed",
    "statusStrength": [
      0.04,
      0.08
    ],
    "statusDuration": 4
  },
  {
    "name": "Morning's Fortune",
    "id": "059",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Successful attacks heal for MODIFIER health",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      10,
      50
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      -1,
      8
    ],
    "applyStatus": false,
    "statusTarget": "self",
    "statusEffect": "bleed",
    "statusStrength": [
      0.04,
      0.08
    ],
    "statusDuration": 4
  },
  {
    "name": "Dusk's Embrace",
    "id": "060",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Successful attacks deal MODIFIER additional damage",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      15,
      75
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      -1,
      8
    ],
    "applyStatus": false,
    "statusTarget": "self",
    "statusEffect": "bleed",
    "statusStrength": [
      0.04,
      0.08
    ],
    "statusDuration": 4
  },
  {
    "name": "Winter's Curse",
    "id": "061",
    "chance": 30,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks have a 30% chance to cause stun effect for 1 turn",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      -1,
      8
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 1
  },
  {
    "name": "Burning Lashes",
    "id": "062",
    "chance": 30,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks have a 30% chance to cause a bleed effect for STRENGTH% of targets health for 3 turns",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      -1,
      8
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.03,
      0.05
    ],
    "statusDuration": 3
  },
  {
    "name": "Predatory Gaze",
    "id": "063",
    "chance": 45,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Tied attacks have a 45% chance to cause a stun effect for 2 turns",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 2,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": [
      -1,
      -1,
      8
    ],
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 2
  },
  {
    "name": "Regenerating Life Force",
    "id": "064",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "Attacks after 10 attacks heal for MODIFIER health and cause a stun effect on the user for 5 turns",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      10,
      100
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": 10,
    "applyStatus": true,
    "statusTarget": "self",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 5
  },
  {
    "name": "Heavy Blade",
    "id": "065",
    "chance": 70,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks have a 70% chance to cause a stagger effect on the user for 1 turn",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "2",
    "clearCounters": false,
    "requiredCounters": 10,
    "applyStatus": true,
    "statusTarget": "self",
    "statusEffect": "stagger",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 1
  },
  {
    "name": "Shattering Blows",
    "id": "066",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "For every Rush, all attacks deal MODIFIER additional damage",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      6,
      60
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": true,
    "equalCounter": "0",
    "clearCounters": false,
    "requiredCounters": 10,
    "applyStatus": false,
    "statusTarget": "self",
    "statusEffect": "stagger",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 1
  },
  {
    "name": "Mighty Spirit",
    "id": "067",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks cause stagger effect for 1 turn",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "heal",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "0",
    "clearCounters": false,
    "requiredCounters": 10,
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stagger",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 1
  },
  {
    "name": "Blade Burst",
    "id": "068",
    "chance": 65,
    "recoil": [
      30,
      150
    ],
    "overpower": false,
    "effectDescription": "All rushes have a 65% chance to deal RECOIL recoil damage and cause a bleed effect on the target for STRENGTH% of their health for 2 turns",
    "effectOnMoves": [
      "0"
    ],
    "effectModifier": "heal",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "0",
    "clearCounters": false,
    "requiredCounters": 10,
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.12,
      0.20
    ],
    "statusDuration": 4
  },
  {
    "name": "Full Payload",
    "id": "069",
    "chance": 0,
    "recoil": [
      30,
      150
    ],
    "overpower": false,
    "effectDescription": "All Successful strikes and counters deal MODIFIER recoil damage and cause a stun effect on the user for 1 turn",
    "effectOnMoves": [
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      20,
      120
    ],
    "requiresSuccess": 1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "0",
    "clearCounters": false,
    "requiredCounters": 10,
    "applyStatus": true,
    "statusTarget": "self",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 1
  },
  {
    "name": "Havoc Swing",
    "id": "071",
    "chance": 60,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All attacks have a 60% chance to cause a bleed effect for STRENGTH% on the target for 1 turn",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "0",
    "clearCounters": false,
    "requiredCounters": 10,
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "bleed",
    "statusStrength": [
      0.10,
      0.20
    ],
    "statusDuration": 1
  },
  {
    "name": "Purge of Nature",
    "id": "072",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All failed attacks stun the enemy for 2 turns",
    "effectOnMoves": [
      "0",
      "1",
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": -1,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "0",
    "clearCounters": false,
    "requiredCounters": 10,
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "stun",
    "statusStrength": [
      0,
      0
    ],
    "statusDuration": 2
  },
  {
    "name": "Adaptive Counter",
    "id": "073",
    "chance": 0,
    "recoil": [
      0,
      0
    ],
    "overpower": false,
    "effectDescription": "All counters cause a dizzy effect on the enemy for STRENGTH%",
    "effectOnMoves": [
      "2"
    ],
    "effectModifier": "damage",
    "modifier": [
      0,
      0
    ],
    "requiresSuccess": 0,
    "requiresCounters": false,
    "modiferValueEqualsCounters": false,
    "equalCounter": "0",
    "clearCounters": false,
    "requiredCounters": 10,
    "applyStatus": true,
    "statusTarget": "enemy",
    "statusEffect": "dizzy",
    "statusStrength": [
      0.325,
      0.75
    ],
    "statusDuration": 2
  }
]
